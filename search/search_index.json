{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MiRco documentation","text":"<p>This documentation contains instructions for working with the <code>MiRco</code> mobile manipulator. <code>MiRco</code> consists of <code>MiR100</code> autonomous mobile robot, <code>UR5e</code> manipulator arm and <code>Robotiq 2F-85</code>  gripper.</p>"},{"location":"#get-started","title":"Get started","text":"<ul> <li><code>MiRco</code> documentation</li> <li><code>MiR100</code> documentation</li> <li><code>UR5e &amp; 2F-85</code> documentation</li> </ul>"},{"location":"#tested-on","title":"Tested on","text":"<ul> <li><code>MiR100</code> robot:<ul> <li>software version 2.13.3.2</li> </ul> </li> <li><code>UR5e</code> manipulator:<ul> <li>Polyscope version: TODO</li> <li>externalcontrol URCap:TODO</li> <li>rs485 URCap: TODO</li> </ul> </li> <li><code>Robotiq 2F-85</code> gripper</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Thank you to the DFKI team for developing and maintaining the ROS <code>mir_robot</code> package.</li> <li>Thank you to the UniversalRobots team for developing and maintaining the ROS <code>Universal_Robots_ROS_Driver</code> package.</li> <li>Thank you to the TAMS-Group team for maintaining the ROS <code>Robotiq</code> package.</li> </ul>"},{"location":"file_structure/","title":"File structure","text":"<p>This page describes the file structure on the <code>MiRco PC</code>. It describes the core files that enable <code>MiRco</code> ROS control.</p> <p>Files are organized in a ROS <code>catkin</code> workspace. If you are not familiar, ROS concepts and catkin workspaces of the official ROS documentation are a good place to start. For a new project/application create a package within the <code>src</code> directory or create a new workspace and source both the new and <code>MiRco_ws</code> workspaces.</p> <pre><code>MiRco_ws/src\n\u251c\u2500\u2500 CMakeLists.txt                  # main CMakeLists file\n\u251c\u2500\u2500 MiRco_robot                     \n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile                  # Docker file, see installation for info\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mirco_description           # MiRco unified URDF\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mirco_moveit_config         # MiRco MoveIt config and launch files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_control                 # MiR100 main control, launch files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mirco_robot                 # MiRco main control, launch files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_joy_teleop              # MiR100 joystick control\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_rest_api                # MiR100 REST API\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ur5e_2f85                   # Arm &amp; gripper main control, launch files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ur5e_2f85_description       # Arm &amp; gripper unified URDF\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ur5e_2f85_moveit_config     # Arm &amp; gripper MoveIt config and launch files\n\u251c\u2500\u2500 mir_robot                       # MiR100 ROS driver\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile-noetic\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LICENSE\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_actions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_description\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_driver\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_dwb_critics\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_gazebo\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_msgs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_navigation\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 mir_robot\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 sdc21x0\n\u251c\u2500\u2500 robotiq_2f85                    # gripper ROS driver \n \u00a0\u00a0 \u251c\u2500\u2500 CONTRIBUTING.md\n \u00a0\u00a0 \u251c\u2500\u2500 LICENSE\n \u00a0\u00a0 \u251c\u2500\u2500 README.md\n \u00a0\u00a0 \u251c\u2500\u2500 robotiq\n \u00a0\u00a0 \u251c\u2500\u2500 robotiq_2f_85_gripper_visualization\n \u00a0\u00a0 \u251c\u2500\u2500 robotiq_2f_gripper_action_server\n \u00a0\u00a0 \u251c\u2500\u2500 robotiq_2f_gripper_control\n \u00a0\u00a0 \u251c\u2500\u2500 robotiq_ethercat\n \u00a0\u00a0 \u251c\u2500\u2500 robotiq_modbus_rtu\n \u00a0\u00a0 \u2514\u2500\u2500 robotiq_modbus_tcp\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li><code>ROS noetic:</code> full desktop version is preferred. Can install other variant dependant on your use case.</li> <li><code>rosdep:</code> command-line tool for installing system dependencies. Follow these install instructions.</li> <li><code>(optional) Docker:</code> allow system flexibility. Viable option for no OS wide ROS install, or for working with multiple ROS versions. See Working with Docker for details. </li> </ul>"},{"location":"installation/#ros-workspace","title":"ROS workspace","text":"<pre><code># create a catkin workspace\nmkdir -p ~/MiRco/ws/src \\\n&amp;&amp; cd ~/MiRco/ws/src\n\n# clone mir_robot, robotiq_2f85 and this repository into the catkin workspace\ngit clone -b noetic https://github.com/JanJericevic/mir_robot.git \\\n&amp;&amp; git clone -b noetic-devel https://github.com/JanJericevic/robotiq_2f85.git \\\n&amp;&amp; git clone -b main https://github.com/JanJericevic/MiRco_robot.git\n\n# update and install packages\nsudo apt update \\\n&amp;&amp; sudo apt upgrade -y \\\n&amp;&amp; sudo apt install -y --no-install-recommends python3-catkin-lint python3-catkin-tools ros-noetic-moveit ros-noetic-ur-robot-driver ros-noetic-ur-calibration ros-noetic-ur-calibration-dbgsym\n\n# use rosdep to install all dependencies\ncd ~/MiRco/ws/ \\\n&amp;&amp; rosdep update \\\n&amp;&amp; rosdep install --from-paths src -i -y --rosdistro noetic \n\n# build all the packages in the catkin workspace\nsource /opt/ros/noetic/setup.bash \\\n&amp;&amp; cd ~/MiRco/ws/src \\\n&amp;&amp; catkin_init_workspace \\\n&amp;&amp; cd ~/MiRco/ws/ \\\n&amp;&amp; catkin_make -DCMAKE_BUILD_TYPE=RelWithDebugInfo\n\n# source the workspace and add it to the .bashrc\nsource ~/MiRco/ws/devel/setup.bash \\\n&amp;&amp; echo \"source ~/MiRco/ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"installation/#working-with-docker","title":"Working with Docker","text":"<p>Docker containers allow you flexibility in your setup: - reproducibility of environments/projects - no need for OS wide ROS install - possibility of switching between ROS versions </p>"},{"location":"installation/#install-docker-engine","title":"Install Docker engine","text":"<p>Full install instructions are available at Dockers official website. Make sure old versions od Docker engine are uninstalled.</p>"},{"location":"installation/#optional-docker-post-installation-steps","title":"Optional Docker post installation steps","text":"<p>All optional installation steps are available at Dockers official website. Useful post installation step is to manage Docker as a non sudo user. This allow the omission of <code>sudo</code> in front of docker commands. When allowing this make sure to be aware of how this impacts security of your system.</p>"},{"location":"installation/#building-the-image","title":"Building the image","text":"<p>If all you want is to connect to the MiR100 <code>roscore</code> for monitoring all you need is a ROS Docker image. We will build a custom ROS Docker image, complete with the same ROS packages as a local install, so you have a choice of running the project locally or using Docker containers.</p> <pre><code># download the desired packages to the src of your workspace\nmkdir -p ~/MiRco/ws/src \\\n&amp;&amp; cd ~/MiRco/ws/src\n\ngit clone -b noetic https://github.com/JanJericevic/mir_robot.git \\\n&amp;&amp; git clone -b noetic-devel https://github.com/JanJericevic/robotiq_2f85.git \\\n&amp;&amp; git clone -b main https://github.com/JanJericevic/MiRco_robot.git\n\n# move the Dockerfile and docker-compose.yaml in MiRco_robot folder to the src folder\nmv ~/MiRco/ws/src/MiRco_robot/Dockerfile ~/MiRco/ws/src \\\n&amp;&amp; mv ~/MiRco/ws/src/MiRco_robot/docker-compose.yaml ~/MiRco/ws/src/docker-compose.yaml\n\n# build the Docker image\ncd ~/MiRco/ws/src\ndocker build -t mirco_docker --build-arg MYUID=$(id -u) --build-arg MYGID=$(id -g) --build-arg MYUSER=$(id -nu) --build-arg MYGROUP=$(id -ng) .\n\n# list your built Docker images\n# verify that your &lt;image-name&gt; is among the listed images\ndocker images\n</code></pre> <p>Note</p> <p>If you're on a machine with no OS wide ROS install and don't have a <code>catkin ws</code> the steps remain the same. Move the <code>Dockerfile</code> to the root directory of your packages, then build the Docker image in that root directory. The build commands remain the same.</p> <p>To avoid permissions issues with shared files between the host computer and the image container, we create a user with <code>sudo</code> permissions inside the image (this is especially relevant during development). User profile can be changed when building the image (the <code>build-arg</code> listed above) and inside the <code>Dockerfile</code>. The current profile settings are: </p> <p>username: same as the host username that built the image password: same as the username</p> <p>The <code>Dockerfile</code> creates a <code>catkin workspace</code> at <code>/home/&lt;your-user&gt;/ws</code> inside the image. The workspace is also set as the work directory of the image so it will be the starting point of every new container.</p> <p>Depending on your use case you will use the Docker image during development (you plan to regularly modify your codebase) or you will only use it for deployment. For deployment you only need to copy your files once, which is what we have done until now. For a development setup see the volume mounting section.</p>"},{"location":"installation/#running-the-image","title":"Running the image","text":"<p>You can start a container with the MiRco image using the <code>docker-compose.yaml</code> file.</p> <pre><code># start the docker container in detached mode\ncd ~/MiRco/ws/src \\\n&amp;&amp; docker compose up -d \\\n\n# open a terminal in the container\ndocker exec -it mirco_container bash\n</code></pre> <p>This Docker compose configuration enables:</p> <ul> <li>GUI usage inside the container (X11 forwarding)</li> <li>NVIDIA GPU utilization (host needs NVIDIA Container Toolkit)</li> <li>device usage inside the container (for joysticks)</li> <li>mounts the src folder of your workspace directory as a volume for persistent memory during development  </li> </ul> <p>Check the <code>docker-compose.yaml</code> file for details how each function is enabled. If these functions are not needed, configure the <code>docker-compose.yaml</code> to your needs.</p>"},{"location":"installation/#gui-applications","title":"GUI applications","text":"<p>If you have problems using GUI applications inside the container try to change access permissions to the X server. The easiest is to grant access to everyone, or you can specify a specific user.</p> <pre><code># disables access control\nxhost +\n\n# grants access to specific user\nxhost +local:&lt;user-name&gt;\n# or\nxhost +SI:local:&lt;user-name&gt;\n</code></pre> <p>Changes to the X server access only persist until the next logout/login, but it is best practice to enable back the access control once you're finished working with the container.</p> <pre><code># enables access control\nxhost -\n</code></pre>"},{"location":"installation/#nvidia","title":"NVIDIA","text":"<p>Users of NVIDIA GPUs can download the NVIDIA Container Toolkit, which allows them to build GPU accelerated containers or in some cases solves display issues if the above mentioned setup is not working. The \"Graphics inside Docker Containers\" paragraph of this  ROS&amp;Docker guide describes working with such images.</p>"},{"location":"installation/#volume-mounting","title":"Volume mounting","text":"<p>For development we want persistent files that are shared between the host machine and the containers, files that can be changed both from the host side and from inside the container, in a setup which does not require us to rebuild the image every time we modify our code. We achieve this using volumes. To achieve the necessary permissions we create a <code>sudo</code> user inside the image (see \"Building the image\" section).</p> <p>Note</p> <p>Mounted files are available only at runtime. Any files needed for building the image should be copied before then.</p>"},{"location":"installation/#input-devices","title":"Input devices","text":"<p>Some input devices require you to change their permissions so that they become accessible to your application (e.g. \"Configuring the Joystick\" section of this ROS tutorial). To avoid repetative changing of permissions every time you plug them in, you can create a <code>udev</code> rule.</p> <pre><code># with the desired input device unplugged\n# list the input devices on your host\n$ ls /dev/input\nby-id    event0  event10  event3  event5  event7  event9  mouse0  mouse2\nby-path  event1  event11  event2   event4  event6  event8  mice    mouse1\n\n# plug in the desired input device\n# again list the input devices to see your device name\n$ ls /dev/input\nby-id    event1   event20  event5  event8  mice    mouse2\nby-path  event10  event19  event3   event6  event9  mouse0\nevent0   event11  event2   event4   event7  js0     mouse1\n</code></pre> <p>Using the above method, we find that our device name is <code>js0</code>. Now we create a <code>udev</code> rule. Add a file <code>/etc/udev/rules.d/99-userdev-input.rules</code> with:</p> <pre><code>KERNEL==\"js0\", SUBSYSTEM==\"input\", ACTION==\"add\", RUN+=\"/usr/bin/setfacl -m o:rw $env{DEVNAME}\"\n</code></pre> <p>This udev rule uses <code>ACL</code> to set the read-write permissions of the input device <code>js0</code> for the <code>others</code> group. You can modify the rule using <code>ACL</code> commands.</p>"},{"location":"MiR100/mir_connection/","title":"Connect to MiR100","text":"<p>There are two ways of interacting with the MiR100 mobile platform:</p> <ul> <li>MiR web interface</li> <li>ROS</li> </ul>"},{"location":"MiR100/mir_connection/#establish-mir-web-interface-connection","title":"Establish MiR web interface connection","text":"<p>You can connect to the web interface over its hotspot or the outside network it is connected to.</p>"},{"location":"MiR100/mir_connection/#hotspot","title":"Hotspot","text":"<ul> <li>connect to the MiR_R*** hotspot with the password</li> <li>open mir.com (default IP = 192.168.12.20) in your browser</li> <li>use your credentials to log in to the web interface</li> </ul>"},{"location":"MiR100/mir_connection/#outside-network","title":"Outside network","text":"<ul> <li>you have to know the <code>MiR100_IP</code>. If you don't, connect to the web interface over hotspot and go to <code>System -&gt; Settings -&gt; WiFi</code>. <code>MiR100_IP</code> is listed under the connection details</li> <li>open <code>MiR100_IP</code> in your browser</li> <li>use your credentials to log in to the web interface</li> </ul> <p>Warning</p> <p>MiR100 internal clock is prone to desynchronization which can mess with the robot control. First thing you have to do after you connect to the MiR web interface is go to <code>System -&gt; Settings -&gt; Date &amp; Time</code> and synchronize the internal clock. Click <code>Load from device</code> and <code>Save changes</code>.</p>"},{"location":"MiR100/mir_connection/#establish-ros-connection","title":"Establish ROS connection","text":"<p><code>MiR100</code> has a running ROS instance on its internal computer. This means you can:</p> <ul> <li>connect to its internal <code>roscore</code></li> <li>recommended: connect using the <code>mir_control</code> package</li> </ul>"},{"location":"MiR100/mir_connection/#internal-roscore","title":"Internal roscore","text":"<p>You have to be connected to the robot hotspot (MiR_R****). Set the ROS master addres to the address of <code>MiR100</code> internal roscore and test the connection.</p> <pre><code># this needs to be done in every terminal\nexport ROS_MASTER_URI=http://192.168.12.20:11311\nexport ROS_HOSTNAME=&lt;your IP: 192.168.12.***&gt;\n\n# test the connection\n# test subscriber\nrostopic list\nrostopic echo /odom\n\n# test publisher\nrostopic pub -r 50 /cmd_vel geometry_msgs/TwistStamped \"header:\n  seq: 0\n  stamp:\n    secs: 0\n    nsecs: 0\n  frame_id: ''\ntwist:\n  linear:\n    x: 0.0\n    y: 0.0\n    z: 0.0\n  angular:\n    x: 0.0\n    y: 0.0\n    z: 0.2\"\n</code></pre>"},{"location":"MiR100/mir_connection/#mir_control-package","title":"mir_control package","text":"<p>Using <code>mir_control</code> you can establish a ROS connection over the MiR_R*** hotspot or the outside network <code>MiR100</code> is connected to.</p>"},{"location":"MiR100/mir_connection/#hotspot_1","title":"Hotspot","text":"<p>If you are connected to the MiR_R**** hotspot:</p> <pre><code># launch mir_control\nroslaunch mir_control mir_control.launch\n</code></pre> <p>Terminal output will hang for a bit on \"ROS bridge connected\" message. Wait until \"MiR100: ...\" messages finish, then continue.</p> <pre><code># test the connection\n# test subscriber\nrostopic echo /odom\n\n# test publisher\nrostopic pub -r 50 /cmd_vel geometry_msgs/Twist \"linear:\n  x: 0.0\n  y: 0.0\n  z: 0.0\nangular:\n  x: 0.0\n  y: 0.0\n  z: 0.2\"\n</code></pre>"},{"location":"MiR100/mir_connection/#outside-network_1","title":"Outside network","text":"<p>If you are connected to the same outside network as <code>MiR100</code>:</p> <p><pre><code># launch mir_control\nroslaunch mir_control mir_control.launch mir_ip:=&lt;MiR100_IP&gt;\n</code></pre> Terminal output will hang for a bit on \"ROS bridge connected\" message. Wait until \"MiR100: ...\" messages finish, then continue.</p> <pre><code># test the connection\n# test subscriber\nrostopic echo /mir100/odom\n\n# test publisher\nrostopic pub -r 50 /mir100/cmd_vel geometry_msgs/Twist \"linear:\n  x: 0.0\n  y: 0.0\n  z: 0.0\nangular:\n  x: 0.0\n  y: 0.0\n  z: 0.2\"\n</code></pre> <p>Note</p> <p>When using <code>mir_control</code> we send <code>geometry_msgs/Twist</code> type messages instead of <code>geometry_msgs/TwistStamped</code> to the <code>/cmd_vel</code> topic. That is because the <code>mir_driver</code> package expects messages of type <code>geometry_msgs/Twist</code> on the <code>/cmd_vel</code> topic and converts them to <code>geometry_msgs/TwistStamped</code> messages before sending the commands to the robot.</p>"},{"location":"MiR100/mir_connection/#connect-mir100-to-a-wifi-network","title":"Connect MiR100 to a WiFi network","text":"<p>You can connect the robot to an outside network:</p> <ul> <li>connect to the MiR_R**** hotspot</li> <li>in the web interface go to <code>System -&gt; Settings -&gt; WiFi</code></li> <li>select \"Add connection\"</li> <li>select the network and fill in required information</li> <li>when you're finished select \"Add connection\"</li> <li><code>MiR100_IP</code> is displayed under the network connection details. You can use this IP to access the web interface or when using <code>mir_control</code></li> </ul>"},{"location":"MiR100/mir_glossary/","title":"Glossary","text":"<p>Positions: Positions are defined as X-Y coordinates with orientation in the map and are used in missions (can also be used outside missions). </p> <p>Marker: Markers are position types used by the robot to dock to physical V, VL, L, or straight bar-shaped objects. Markers are used when you want the robot to position itself accurately relative to a physical object.</p>"},{"location":"MiR100/mir_overview/","title":"MiR100 overview","text":"<p>MiR100 is an entry-level autonomous mobile robot (AMR) from Mobile Industrial Robots (MiR). </p> <p>The platform has a payload capacity of 100 kg and can reach speeds of up to 1.5 m/s. It is equipped with two SICK S300 lidar systems, an Intel RealSense 3D camera and four ultrasonic sensors.</p> <p>The main robot interface is the MiR web interface. The web interface is used to design robot applications and interact with the robot.</p> <p>It has an internal computer which acts as the main control system. The internal computer runs a ROS instance that we can use to control the robot.</p>"},{"location":"MiR100/mir_rest_api/","title":"MiR REST API reference","text":"<p>MIR100 REST API</p> <p>This API does not contain every endpoint in the MiR100 REST API! It contains only endpoints useful to the author at the time of development.</p> <p>Instructions: Don't forget to set login credentials for the robot REST authorization header. Don't forget to set the robot IP if using other network than MiR100 internal hotspot.</p> <p>Two ways of sending REST requests:</p> <ul> <li>handle_request(): send direct REST request to the robot API</li> <li>handle_request_ros(): send REST request over ROS service. Requires ROS service server node running</li> </ul>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi","title":"<code>MirRestApi</code>","text":"<p>MiR REST API class</p> <p>Parameters:</p> Name Type Description Default <code>usrname</code> <code>str</code> <p>MiR interface username. Used to generate authorization header.</p> required <code>password</code> <code>str</code> <p>MiR interface password. Used to generate authorization header.</p> required <code>ip</code> <code>str</code> <p>robot IP, defaults to \"192.168.12.20\"</p> <code>'192.168.12.20'</code> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>class MirRestApi:\n    \"\"\"MiR REST API class\n\n    :param usrname: MiR interface username. Used to generate authorization header.\n    :type usrname: str\n    :param password: MiR interface password. Used to generate authorization header.\n    :type password: str\n    :param ip: robot IP, defaults to \"192.168.12.20\"\n    :type ip: str, optional\n    \"\"\"\n\n    def __init__(self, usrname: str, password: str, ip: str = \"192.168.12.20\") -&gt; None:\n        self.url = \"http://\" + ip + \"/api/v2.0.0\"\n        self.header = {\n            'Content-Type': 'application/json',\n            'Authorization': self.generate_auth_head(usrname, password)\n            }\n\n        # when sending requests over ROS services we need a service handle\n        self.service_handle = rospy.ServiceProxy('mir_rest_api_service', Rest)\n\n    def generate_auth_head(self, usrname: str, password: str) -&gt; str:\n        \"\"\"generate authorization header\n\n        :param usrname: MiR interface username\n        :type usrname: str\n        :param password: MiR interface password\n        :type password: str\n        :return: authorization string\n        :rtype: str\n        \"\"\"\n\n        hashed_pass = hashlib.sha256(password.encode('utf-8')).hexdigest()\n        string = usrname + \":\" + hashed_pass\n        string_bytes = string.encode(\"ascii\")\n        base64_bytes = base64.b64encode(string_bytes)\n        base64_string = base64_bytes.decode(\"ascii\")\n        auth_header = \"Basic \" + base64_string\n        return auth_header\n\n    def handle_request(self) -&gt; [int, dict]:\n        \"\"\"Handle REST request\n\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        if self.method == \"GET\":\n            try:\n                response = requests.get(self.endpoint, headers=self.header)\n                response = [response.status_code, response.json()]\n                return response\n            except Exception as e:\n                # rospy.logerr(e)\n                print(e) \n\n        elif self.method == \"DELETE\":\n            try:\n                response = requests.delete(self.endpoint, headers=self.header)\n                response = [response.status_code, {}]\n                return response\n            except Exception as e:\n                # rospy.logerr(e)\n                print(e) \n\n        elif self.method == \"POST\":\n            try:\n                response = requests.post(self.endpoint, json=self.json, headers=self.header)\n                response = [response.status_code, response.json()]\n                # if response[0] != 200:\n                #     pprint(response[1])\n                return response\n            except Exception as e:\n                # rospy.logerr(e)\n                print(e) \n\n        elif self.method == \"PUT\":\n            try:\n                response = requests.put(self.endpoint, json=self.json, headers=self.header)\n                response = [response.status_code, response.json()]\n                # if response[0] != 200:\n                #     pprint(response[1])\n                return response\n            except Exception as e:\n                # rospy.logerr(e)\n                print(e)  \n\n        else:\n            # rospy.loginfo(\"Incorrect REST method!\")\n            print(\"Incorrect REST method!\")\n\n    def handle_request_ros(self) -&gt; RestResponse:\n        \"\"\"Handle REST request over ROS service. Needs ROS service server node running\n\n        :return: ROS service response containing REST response status code and body\n        :rtype: RestResponse\n        \"\"\"\n\n        try:\n            response = self.service_handle(self.method, json.dumps(self.header), self.endpoint, json.dumps(self.json))\n            response = [response.status_code, json.loads(response.response)]\n            return response\n        except rospy.ServiceException as e:\n            rospy.logerr(e)\n\n\n    # MiR REST API endpoints:\n    # -------- robot settings ---------\n    def settings_groups_get(self, ros: bool = 0) -&gt; [int, List[dict]]:\n        \"\"\"Retrieve a list with the settings groups\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int, List[dict]]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/setting_groups\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def settings_groups_id_get(self, group_id: int, ros: bool = 0) -&gt; [int, List[dict]]:\n        \"\"\"Retrieve the list of settings from the settings group with the specified settings group ID\n\n        :param group_id: settings group ID\n        :type group_id: int\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int, List[dict]]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/setting_groups/\" + str(group_id) + \"/settings\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def settings_groups_name_get(self, group_name: str, ros: bool = 0) -&gt; [int, List[dict]]:\n        \"\"\"Retrieve the list of settings from the settings group with the specified settings group name\n\n        :param group_name: settings group name\n        :type group_name: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int, List[dict]]\n        \"\"\"\n\n        groups = self.settings_groups_get(ros)\n        setting_group = next(item for item in groups[1] if item[\"name\"] == group_name)\n        setting_group = self.settings_groups_id_get(setting_group[\"id\"],ros)\n        return setting_group\n\n    def setting_name_get(self, group_name: str, setting_name: str, ros: bool = 0) -&gt; [int,dict]:\n        \"\"\"Retrieve the details of the setting with the specified settings group name and setting name\n\n        :param group_name: settings group name\n        :type group_name: str\n        :param setting_name: setting name\n        :type setting_name: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int,dict]\n        \"\"\"\n\n        settings_list = self.settings_groups_name_get(group_name,ros)\n        setting = next(item for item in settings_list[1] if item[\"name\"] == setting_name)\n        return [settings_list[0], setting]\n\n    def setting_name_put(self, group_name: str, setting_name: str, setting_value: str, ros: bool = 0) -&gt; [int,dict]:\n\n        setting_id = self.setting_name_get(group_name, setting_name, ros)[1][\"id\"]\n\n        self.method = \"PUT\"\n        self.endpoint = self.url + \"/settings/\" + str(setting_id)\n        self.json = {\"value\": str(setting_value)}\n        if ros == 1:\n            response =  self.handle_request_ros()\n            return [response[0], {\"name\": response[1][\"name\"],\"value\": response[1][\"value\"]}]\n        else:\n            response =  self.handle_request()\n            return [response[0], {\"name\": response[1][\"name\"],\"value\": response[1][\"value\"]}]\n\n    # ---------- robot state ----------\n    def status_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the robot status\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/status\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def status_put(self, json: dict, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Modify the robot status\n\n        :param json: request body\n        :type json: dict\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"PUT\"\n        self.endpoint = self.url + \"/status\"\n        self.json = json\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def status_mode_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the current mode of the robot\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/status\"\n        self.json = \"\"\n        if ros == 1:\n            response =  self.handle_request_ros()\n            return [response[0], {\"mode_id\": response[1][\"mode_id\"],\"mode_text\": response[1][\"mode_text\"], \"mode_key_state\":response[1][\"mode_key_state\"]}]\n        else:\n            response =  self.handle_request()\n            return [response[0], {\"mode_id\": response[1][\"mode_id\"],\"mode_text\": response[1][\"mode_text\"], \"mode_key_state\":response[1][\"mode_key_state\"]}]\n\n    def status_state_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the current state of the robot\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/status\"\n        self.json = \"\"\n        if ros == 1:\n            response =  self.handle_request_ros()\n            return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n        else:\n            response =  self.handle_request()\n            return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n\n    def status_state_id_put(self, state_id: int, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Modify the current state of the robot. \n\n        Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}.\n        Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}.\n\n        :param state_id: desired robot state\n        :type state_id: int\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        if state_id !=3 and state_id != 4:\n            print(\"INVALID INPUT. Select state_id=3 for 'Ready' or state_id=4 for 'Pause'\")\n            return\n\n        self.method = \"PUT\"\n        self.endpoint = self.url + \"/status\"\n        self.json = {\"state_id\" : state_id}\n        if ros == 1:\n            response =  self.handle_request_ros()\n            return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n        else:\n            response =  self.handle_request()\n            return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n\n\n    def status_state_id_toggle_put(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'.\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        status = self.status_state_get(ros)[1]\n        if status[\"state_id\"] == 3:\n            state_id = 4\n            # rospy.loginfo(\"Setting the robot state to: 'Pause'\")\n            print(\"Robot is in state: 'Ready'. Setting the robot state to: 'Pause'\")\n        elif status[\"state_id\"] == 4:\n            state_id = 3\n            # rospy.loginfo(\"Setting the robot state to: 'Ready'\")\n            print(\"Robot is in state: 'Pause'. Setting the robot state to: 'Ready'/'Executing'\")\n        elif status [\"state_id\"] == 5:\n            state_id = 4\n            # rospy.loginfo(\"Setting the robot state to: 'Ready'\")\n            print(\"Robot is in state: 'Executing'. Setting the robot state to: 'Pause'\")\n        elif status [\"state_id\"] == 10:\n            # rospy.loginfo(\"Setting the robot state to: 'Ready'\")\n            print(\"Robot is in state: 'EmergencyStop'. Unable to toggle robot status\")\n            return\n        else:\n            # rospy.logerr(\"Unable to toggle robot status\")\n            print(\"Unable to toggle robot status\")\n            return\n\n        self.method = \"PUT\"\n        self.endpoint = self.url + \"/status\"\n        self.json = {\"state_id\" : state_id}\n        if ros == 1:\n            response =  self.handle_request_ros()\n            return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n        else:\n            response =  self.handle_request()\n            return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n\n    # ---------- missions ----------\n    def mission_groups_get(self, ros: bool = 0) -&gt; [int, List[dict]]:\n        \"\"\"Retrieve the list of mission groups\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, List[dict]]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/mission_groups\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def mission_groups_group_id_missions_get(self, group_id: str, ros: bool = 0) -&gt; [int, List[dict]]:\n        \"\"\"Retrieve the list of missions that belong to the group with the specified group ID\n\n        :param group_id: mission group ID\n        :type group_id: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, List[dict]]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/mission_groups/\" + group_id + \"/missions\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_groups_group_name_missions_get(self, group_name: str, ros: bool = 0) -&gt; [int, List[dict]]:\n        \"\"\"Retrieve the list of missions that belong to the group with the specified group name\n\n        :param group_name: missions group name\n        :type group_name: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int, List[dict]]\n        \"\"\"\n\n        mission_groups = self.mission_groups_get(ros)\n        group = next(item for item in mission_groups[1] if item[\"name\"] == str(group_name))\n        group_guid = group[\"guid\"]\n\n        missions = self.mission_groups_group_id_missions_get(group_guid, ros)\n        return missions\n\n    def missions_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of missions\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/missions\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_guid_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the details about the mission with the specified GUID\n\n        :param guid: mission GUID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/missions/\" + guid\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_guid_delete(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Erase the mission with the specified GUID\n\n        :param guid: mission GUID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"DELETE\"\n        self.endpoint = self.url + \"/missions/\" + guid\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_guid_definition_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission\n\n        :param guid: mission GUID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/missions/\" + guid + \"/definition\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_mission_id_actions_get(self, mission_id: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of actions that belong to the mission with the specified mission ID\n\n        :param mission_id: mission ID\n        :type mission_id: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_mission_id_actions_guid_get(self, mission_id: str, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID\n\n        :param mission_id: mission ID\n        :type mission_id: str\n        :param guid: action GUID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions/\" + guid\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_mission_id_actions_guid_put(self, mission_id: str, guid: str, action_msg, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Modify the values of the action with the specified GUID that belongs to the mission with the specified mission ID\n\n        :param mission_id: mission ID\n        :type mission_id: str\n        :param guid: action GUID\n        :type guid: str\n        :param action_msg: MiR action body\n        :type action_msg: json\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"PUT\"\n        self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions/\" + guid\n        self.json = action_msg\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def missions_mission_id_actions_guid_delete(self, mission_id: str, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Erase the action with the specified GUID from the mission with the specified mission ID\n\n        :param mission_id: mission ID\n        :type mission_id: str\n        :param guid: action GUID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"DELETE\"\n        self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions/\" + guid\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    # ---------- mission queue ----------\n    def mission_queue_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/mission_queue\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def mission_queue_post(self, mission_id: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Add a new mission to the mission queue. The mission will always go to the end of the queue\n\n        :param mission_id: mission ID\n        :type mission_id: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"POST\"\n        self.endpoint = self.url + \"/mission_queue\"\n        self.json = {\"mission_id\": mission_id}\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def mission_queue_delete(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Abort all the pending and executing missions from the mission queue\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"DELETE\"\n        self.endpoint = self.url + \"/mission_queue\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def mission_queue_id_get(self, id: int, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the details about the mission with the specified ID in the mission queue\n\n        :param id: mission ID in the mission queue\n        :type id: int\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/mission_queue/\" + str(id)\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def mission_queue_id_delete(self, id: int, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Abort the mission with the specified ID in the mission queue\n\n        :param id: mission ID in the mission queue\n        :type id: int\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"DELETE\"\n        self.endpoint = self.url + \"/mission_queue/\" + str(id)\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def mission_queue_mission_queue_id_actions_get(self, mission_queue_id: int, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of actions from the mission with the specified ID in the mission queue\n\n        :param mission_queue_id: mission ID in the mission queue\n        :type mission_queue_id: int\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/mission_queue/\" + str(mission_queue_id) + \"/actions\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def mission_queue_mission_queue_id_actions_id_get(self, mission_queue_id: int, id: int, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue\n\n        :param mission_queue_id: mission ID in the mission queue\n        :type mission_queue_id: int\n        :param id: action ID\n        :type id: int\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/mission_queue/\" + str(mission_queue_id) + \"/actions/\" + str(id)\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    # ---------- maps----------\n    def maps_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of maps\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/maps\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def sessions_session_id_maps_get(self, session_id: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id\n\n        :param session_id: site ID\n        :type session_id: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/sessions/\" + session_id + \"/maps\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def maps_guid_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the details about the map with the specified GUID\n\n        :param guid: map GUID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/maps/\" + guid\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def maps_guid_delete(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Erase the map with the specified GUID\n\n        :param guid: map GUID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"DELETE\"\n        self.endpoint = self.url + \"/maps/\" + guid\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    # ---------- positions ----------\n    def positions_post(self, position, ros: bool = 0) -&gt; [int, dict]: \n        \"\"\"Add a new position.\n\n        Position json needs to have at least: {name, pos_x, pos_y, orientation, type_id, map_id}\n\n        :param position: position json\n        :type position: json\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int, dict]\n        \"\"\"\n\n        self.method = \"POST\"\n        self.endpoint = self.url + \"/positions\"\n        self.json = position\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def maps_map_id_positions_get(self, map_id: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of positions that belong to the map with the specified map ID\n\n        :param map_id: map ID\n        :type map_id: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/maps/\" + map_id + \"/positions\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def positions_guid_get(self, guid: str, ros: bool = 0) -&gt; [int,dict]:\n        \"\"\"Retrieve the details about the position with the specified GUID\n\n        :param guid: The global id unique across robots that identifies this position\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int,dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/positions/\" + guid\n        self.json = \"\"\n\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def positions_pos_id_docking_offsets_get(self, pos_id: str, ros: bool = 0) -&gt; [int,dict]:\n        \"\"\"Retrieve the details of the docking offset of the position with the specified position ID\n\n        :param pos_id: position ID\n        :type pos_id: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int,dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/positions/\" + pos_id + \"/docking_offsets\"\n        self.json = \"\"\n\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def position_transition_lists_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of position transition lists\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/position_transition_lists\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def position_types_id_get(self, id: str, ros: bool = 0) -&gt; [int,dict]:\n        \"\"\"Retrieve the details about the position type with the specified type ID\n\n        :param guid: position type ID\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int,dict]\n        \"\"\"\n\n        \"\"\" Position Types:\n        {'id': 0, 'name': 'Robot position', 'url': '/v2.0.0/position_types/0'},\n        {'id': 1, 'name': 'Cart position', 'url': '/v2.0.0/position_types/1'},\n        {'id': 2, 'name': 'Cart pickup position', 'url': '/v2.0.0/position_types/2'},\n        {'id': 3, 'name': 'Cart left entry', 'url': '/v2.0.0/position_types/3'},\n        {'id': 4, 'name': 'Cart right entry', 'url': '/v2.0.0/position_types/4'},\n        {'id': 5, 'name': 'Shelf position', 'url': '/v2.0.0/position_types/5'},\n        {'id': 6, 'name': 'Shelf short entry position', 'url': '/v2.0.0/position_types/6'},\n        {'id': 7, 'name': 'MiRCharge 100/200', 'url': '/v2.0.0/position_types/7'},\n        {'id': 8, 'name': 'MiRCharge 100/200 entry', 'url': '/v2.0.0/position_types/8'},\n        {'id': 9, 'name': 'V-marker', 'url': '/v2.0.0/position_types/9'},\n        {'id': 10, 'name': 'V-marker entry', 'url': '/v2.0.0/position_types/10'},\n        {'id': 11, 'name': 'VL-marker', 'url': '/v2.0.0/position_types/11'},\n        {'id': 12, 'name': 'VL-marker entry', 'url': '/v2.0.0/position_types/12'},\n        {'id': 13, 'name': 'L-marker', 'url': '/v2.0.0/position_types/13'},\n        {'id': 14, 'name': 'L-marker entry', 'url': '/v2.0.0/position_types/14'},\n        {'id': 15, 'name': 'Emergency position', 'url': '/v2.0.0/position_types/15'},\n        {'id': 16, 'name': 'Precision marker', 'url': '/v2.0.0/position_types/16'},\n        {'id': 17, 'name': 'Precision marker entry', 'url': '/v2.0.0/position_types/17'},\n        {'id': 18, 'name': 'Pallet rack', 'url': '/v2.0.0/position_types/18'},\n        {'id': 19, 'name': 'Pallet rack entry position', 'url': '/v2.0.0/position_types/19'},\n        {'id': 20, 'name': 'MiRCharge 500/1000', 'url': '/v2.0.0/position_types/20'},\n        {'id': 21, 'name': 'MiRCharge 500/1000 entry', 'url': '/v2.0.0/position_types/21'},\n        {'id': 22, 'name': 'Bar-marker', 'url': '/v2.0.0/position_types/22'},\n        {'id': 23, 'name': 'Bar-marker entry', 'url': '/v2.0.0/position_types/23'},\n        {'id': 25, 'name': 'elevator position', 'url': '/v2.0.0/position_types/25'},\n        {'id': 26, 'name': 'elevator entry position', 'url': '/v2.0.0/position_types/26'},\n        {'id': 42, 'name': 'Staging position', 'url': '/v2.0.0/position_types/42'},\n        {'id': 106, 'name': 'Shelf long entry position', 'url': '/v2.0.0/position_types/106'}]]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/position_types/\" + id\n        self.json = \"\"\n\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def position_types_get(self, ros: bool = 0) -&gt; [int,dict]:\n        \"\"\"Retrieve a list of possible position types\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: [int,dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/position_types\"\n        self.json = \"\"\n\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    # ---------- actions ----------\n    def actions_get(self, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the list of action definitions\n\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/actions\"\n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def actions_action_type_get(self, action_type: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the details about the action type. It displays the parameters of the action and the limits for the values among others\n\n        :param action_type: action type\n        :type action_type: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/actions/\" + action_type \n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    # ---------- docking offsets ----------\n    def docking_offsets_guid_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Retrieve the details of the docking offset with the specified GUID\n\n        :param guid: action docking offset guid\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"GET\"\n        self.endpoint = self.url + \"/docking_offsets/\" + guid \n        self.json = \"\"\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n\n    def docking_offsets_guid_put(self, guid: str, offsets, ros: bool = 0) -&gt; [int, dict]:\n        \"\"\"Modify the values of the docking offset with the specified GUID\n\n        :param guid: action docking offset guid\n        :type guid: str\n        :param ros: use ROS service, defaults to 0\n        :type ros: bool, optional\n        :return: a list containing REST response status code and body\n        :rtype: list[int, dict]\n        \"\"\"\n\n        self.method = \"PUT\"\n        self.endpoint = self.url + \"/docking_offsets/\" + guid \n        self.json = offsets\n        if ros == 1:\n            return self.handle_request_ros()\n        else:\n            return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.actions_action_type_get","title":"<code>actions_action_type_get(action_type, ros=0)</code>","text":"<p>Retrieve the details about the action type. It displays the parameters of the action and the limits for the values among others</p> <p>Parameters:</p> Name Type Description Default <code>action_type</code> <code>str</code> <p>action type</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def actions_action_type_get(self, action_type: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the details about the action type. It displays the parameters of the action and the limits for the values among others\n\n    :param action_type: action type\n    :type action_type: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/actions/\" + action_type \n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.actions_get","title":"<code>actions_get(ros=0)</code>","text":"<p>Retrieve the list of action definitions</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def actions_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of action definitions\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/actions\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.docking_offsets_guid_get","title":"<code>docking_offsets_guid_get(guid, ros=0)</code>","text":"<p>Retrieve the details of the docking offset with the specified GUID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>action docking offset guid</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def docking_offsets_guid_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the details of the docking offset with the specified GUID\n\n    :param guid: action docking offset guid\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/docking_offsets/\" + guid \n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.docking_offsets_guid_put","title":"<code>docking_offsets_guid_put(guid, offsets, ros=0)</code>","text":"<p>Modify the values of the docking offset with the specified GUID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>action docking offset guid</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def docking_offsets_guid_put(self, guid: str, offsets, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Modify the values of the docking offset with the specified GUID\n\n    :param guid: action docking offset guid\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"PUT\"\n    self.endpoint = self.url + \"/docking_offsets/\" + guid \n    self.json = offsets\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.generate_auth_head","title":"<code>generate_auth_head(usrname, password)</code>","text":"<p>generate authorization header</p> <p>Parameters:</p> Name Type Description Default <code>usrname</code> <code>str</code> <p>MiR interface username</p> required <code>password</code> <code>str</code> <p>MiR interface password</p> required <p>Returns:</p> Type Description <code>str</code> <p>authorization string</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def generate_auth_head(self, usrname: str, password: str) -&gt; str:\n    \"\"\"generate authorization header\n\n    :param usrname: MiR interface username\n    :type usrname: str\n    :param password: MiR interface password\n    :type password: str\n    :return: authorization string\n    :rtype: str\n    \"\"\"\n\n    hashed_pass = hashlib.sha256(password.encode('utf-8')).hexdigest()\n    string = usrname + \":\" + hashed_pass\n    string_bytes = string.encode(\"ascii\")\n    base64_bytes = base64.b64encode(string_bytes)\n    base64_string = base64_bytes.decode(\"ascii\")\n    auth_header = \"Basic \" + base64_string\n    return auth_header\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.handle_request","title":"<code>handle_request()</code>","text":"<p>Handle REST request</p> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def handle_request(self) -&gt; [int, dict]:\n    \"\"\"Handle REST request\n\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    if self.method == \"GET\":\n        try:\n            response = requests.get(self.endpoint, headers=self.header)\n            response = [response.status_code, response.json()]\n            return response\n        except Exception as e:\n            # rospy.logerr(e)\n            print(e) \n\n    elif self.method == \"DELETE\":\n        try:\n            response = requests.delete(self.endpoint, headers=self.header)\n            response = [response.status_code, {}]\n            return response\n        except Exception as e:\n            # rospy.logerr(e)\n            print(e) \n\n    elif self.method == \"POST\":\n        try:\n            response = requests.post(self.endpoint, json=self.json, headers=self.header)\n            response = [response.status_code, response.json()]\n            # if response[0] != 200:\n            #     pprint(response[1])\n            return response\n        except Exception as e:\n            # rospy.logerr(e)\n            print(e) \n\n    elif self.method == \"PUT\":\n        try:\n            response = requests.put(self.endpoint, json=self.json, headers=self.header)\n            response = [response.status_code, response.json()]\n            # if response[0] != 200:\n            #     pprint(response[1])\n            return response\n        except Exception as e:\n            # rospy.logerr(e)\n            print(e)  \n\n    else:\n        # rospy.loginfo(\"Incorrect REST method!\")\n        print(\"Incorrect REST method!\")\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.handle_request_ros","title":"<code>handle_request_ros()</code>","text":"<p>Handle REST request over ROS service. Needs ROS service server node running</p> <p>Returns:</p> Type Description <code>RestResponse</code> <p>ROS service response containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def handle_request_ros(self) -&gt; RestResponse:\n    \"\"\"Handle REST request over ROS service. Needs ROS service server node running\n\n    :return: ROS service response containing REST response status code and body\n    :rtype: RestResponse\n    \"\"\"\n\n    try:\n        response = self.service_handle(self.method, json.dumps(self.header), self.endpoint, json.dumps(self.json))\n        response = [response.status_code, json.loads(response.response)]\n        return response\n    except rospy.ServiceException as e:\n        rospy.logerr(e)\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.maps_get","title":"<code>maps_get(ros=0)</code>","text":"<p>Retrieve the list of maps</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def maps_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of maps\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/maps\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.maps_guid_delete","title":"<code>maps_guid_delete(guid, ros=0)</code>","text":"<p>Erase the map with the specified GUID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>map GUID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def maps_guid_delete(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Erase the map with the specified GUID\n\n    :param guid: map GUID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"DELETE\"\n    self.endpoint = self.url + \"/maps/\" + guid\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.maps_guid_get","title":"<code>maps_guid_get(guid, ros=0)</code>","text":"<p>Retrieve the details about the map with the specified GUID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>map GUID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def maps_guid_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the details about the map with the specified GUID\n\n    :param guid: map GUID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/maps/\" + guid\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.maps_map_id_positions_get","title":"<code>maps_map_id_positions_get(map_id, ros=0)</code>","text":"<p>Retrieve the list of positions that belong to the map with the specified map ID</p> <p>Parameters:</p> Name Type Description Default <code>map_id</code> <code>str</code> <p>map ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def maps_map_id_positions_get(self, map_id: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of positions that belong to the map with the specified map ID\n\n    :param map_id: map ID\n    :type map_id: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/maps/\" + map_id + \"/positions\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_groups_get","title":"<code>mission_groups_get(ros=0)</code>","text":"<p>Retrieve the list of mission groups</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, List[dict]]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_groups_get(self, ros: bool = 0) -&gt; [int, List[dict]]:\n    \"\"\"Retrieve the list of mission groups\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, List[dict]]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/mission_groups\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_groups_group_id_missions_get","title":"<code>mission_groups_group_id_missions_get(group_id, ros=0)</code>","text":"<p>Retrieve the list of missions that belong to the group with the specified group ID</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>mission group ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, List[dict]]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_groups_group_id_missions_get(self, group_id: str, ros: bool = 0) -&gt; [int, List[dict]]:\n    \"\"\"Retrieve the list of missions that belong to the group with the specified group ID\n\n    :param group_id: mission group ID\n    :type group_id: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, List[dict]]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/mission_groups/\" + group_id + \"/missions\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_queue_delete","title":"<code>mission_queue_delete(ros=0)</code>","text":"<p>Abort all the pending and executing missions from the mission queue</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_queue_delete(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Abort all the pending and executing missions from the mission queue\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"DELETE\"\n    self.endpoint = self.url + \"/mission_queue\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_queue_get","title":"<code>mission_queue_get(ros=0)</code>","text":"<p>Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_queue_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/mission_queue\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_queue_id_delete","title":"<code>mission_queue_id_delete(id, ros=0)</code>","text":"<p>Abort the mission with the specified ID in the mission queue</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>mission ID in the mission queue</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_queue_id_delete(self, id: int, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Abort the mission with the specified ID in the mission queue\n\n    :param id: mission ID in the mission queue\n    :type id: int\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"DELETE\"\n    self.endpoint = self.url + \"/mission_queue/\" + str(id)\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_queue_id_get","title":"<code>mission_queue_id_get(id, ros=0)</code>","text":"<p>Retrieve the details about the mission with the specified ID in the mission queue</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>mission ID in the mission queue</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_queue_id_get(self, id: int, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the details about the mission with the specified ID in the mission queue\n\n    :param id: mission ID in the mission queue\n    :type id: int\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/mission_queue/\" + str(id)\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_queue_mission_queue_id_actions_get","title":"<code>mission_queue_mission_queue_id_actions_get(mission_queue_id, ros=0)</code>","text":"<p>Retrieve the list of actions from the mission with the specified ID in the mission queue</p> <p>Parameters:</p> Name Type Description Default <code>mission_queue_id</code> <code>int</code> <p>mission ID in the mission queue</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_queue_mission_queue_id_actions_get(self, mission_queue_id: int, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of actions from the mission with the specified ID in the mission queue\n\n    :param mission_queue_id: mission ID in the mission queue\n    :type mission_queue_id: int\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/mission_queue/\" + str(mission_queue_id) + \"/actions\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_queue_mission_queue_id_actions_id_get","title":"<code>mission_queue_mission_queue_id_actions_id_get(mission_queue_id, id, ros=0)</code>","text":"<p>Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue</p> <p>Parameters:</p> Name Type Description Default <code>mission_queue_id</code> <code>int</code> <p>mission ID in the mission queue</p> required <code>id</code> <code>int</code> <p>action ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_queue_mission_queue_id_actions_id_get(self, mission_queue_id: int, id: int, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue\n\n    :param mission_queue_id: mission ID in the mission queue\n    :type mission_queue_id: int\n    :param id: action ID\n    :type id: int\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/mission_queue/\" + str(mission_queue_id) + \"/actions/\" + str(id)\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.mission_queue_post","title":"<code>mission_queue_post(mission_id, ros=0)</code>","text":"<p>Add a new mission to the mission queue. The mission will always go to the end of the queue</p> <p>Parameters:</p> Name Type Description Default <code>mission_id</code> <code>str</code> <p>mission ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def mission_queue_post(self, mission_id: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Add a new mission to the mission queue. The mission will always go to the end of the queue\n\n    :param mission_id: mission ID\n    :type mission_id: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"POST\"\n    self.endpoint = self.url + \"/mission_queue\"\n    self.json = {\"mission_id\": mission_id}\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_get","title":"<code>missions_get(ros=0)</code>","text":"<p>Retrieve the list of missions</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of missions\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/missions\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_groups_group_name_missions_get","title":"<code>missions_groups_group_name_missions_get(group_name, ros=0)</code>","text":"<p>Retrieve the list of missions that belong to the group with the specified group name</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>missions group name</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int, List[dict]]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_groups_group_name_missions_get(self, group_name: str, ros: bool = 0) -&gt; [int, List[dict]]:\n    \"\"\"Retrieve the list of missions that belong to the group with the specified group name\n\n    :param group_name: missions group name\n    :type group_name: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int, List[dict]]\n    \"\"\"\n\n    mission_groups = self.mission_groups_get(ros)\n    group = next(item for item in mission_groups[1] if item[\"name\"] == str(group_name))\n    group_guid = group[\"guid\"]\n\n    missions = self.mission_groups_group_id_missions_get(group_guid, ros)\n    return missions\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_guid_definition_get","title":"<code>missions_guid_definition_get(guid, ros=0)</code>","text":"<p>Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>mission GUID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_guid_definition_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission\n\n    :param guid: mission GUID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/missions/\" + guid + \"/definition\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_guid_delete","title":"<code>missions_guid_delete(guid, ros=0)</code>","text":"<p>Erase the mission with the specified GUID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>mission GUID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_guid_delete(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Erase the mission with the specified GUID\n\n    :param guid: mission GUID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"DELETE\"\n    self.endpoint = self.url + \"/missions/\" + guid\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_guid_get","title":"<code>missions_guid_get(guid, ros=0)</code>","text":"<p>Retrieve the details about the mission with the specified GUID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>mission GUID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_guid_get(self, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the details about the mission with the specified GUID\n\n    :param guid: mission GUID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/missions/\" + guid\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_mission_id_actions_get","title":"<code>missions_mission_id_actions_get(mission_id, ros=0)</code>","text":"<p>Retrieve the list of actions that belong to the mission with the specified mission ID</p> <p>Parameters:</p> Name Type Description Default <code>mission_id</code> <code>str</code> <p>mission ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_mission_id_actions_get(self, mission_id: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of actions that belong to the mission with the specified mission ID\n\n    :param mission_id: mission ID\n    :type mission_id: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_mission_id_actions_guid_delete","title":"<code>missions_mission_id_actions_guid_delete(mission_id, guid, ros=0)</code>","text":"<p>Erase the action with the specified GUID from the mission with the specified mission ID</p> <p>Parameters:</p> Name Type Description Default <code>mission_id</code> <code>str</code> <p>mission ID</p> required <code>guid</code> <code>str</code> <p>action GUID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_mission_id_actions_guid_delete(self, mission_id: str, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Erase the action with the specified GUID from the mission with the specified mission ID\n\n    :param mission_id: mission ID\n    :type mission_id: str\n    :param guid: action GUID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"DELETE\"\n    self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions/\" + guid\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_mission_id_actions_guid_get","title":"<code>missions_mission_id_actions_guid_get(mission_id, guid, ros=0)</code>","text":"<p>Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID</p> <p>Parameters:</p> Name Type Description Default <code>mission_id</code> <code>str</code> <p>mission ID</p> required <code>guid</code> <code>str</code> <p>action GUID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_mission_id_actions_guid_get(self, mission_id: str, guid: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID\n\n    :param mission_id: mission ID\n    :type mission_id: str\n    :param guid: action GUID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions/\" + guid\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.missions_mission_id_actions_guid_put","title":"<code>missions_mission_id_actions_guid_put(mission_id, guid, action_msg, ros=0)</code>","text":"<p>Modify the values of the action with the specified GUID that belongs to the mission with the specified mission ID</p> <p>Parameters:</p> Name Type Description Default <code>mission_id</code> <code>str</code> <p>mission ID</p> required <code>guid</code> <code>str</code> <p>action GUID</p> required <code>action_msg</code> <code>json</code> <p>MiR action body</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def missions_mission_id_actions_guid_put(self, mission_id: str, guid: str, action_msg, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Modify the values of the action with the specified GUID that belongs to the mission with the specified mission ID\n\n    :param mission_id: mission ID\n    :type mission_id: str\n    :param guid: action GUID\n    :type guid: str\n    :param action_msg: MiR action body\n    :type action_msg: json\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"PUT\"\n    self.endpoint = self.url + \"/missions/\" + mission_id + \"/actions/\" + guid\n    self.json = action_msg\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.position_transition_lists_get","title":"<code>position_transition_lists_get(ros=0)</code>","text":"<p>Retrieve the list of position transition lists</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def position_transition_lists_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of position transition lists\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/position_transition_lists\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.position_types_get","title":"<code>position_types_get(ros=0)</code>","text":"<p>Retrieve a list of possible position types</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int,dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def position_types_get(self, ros: bool = 0) -&gt; [int,dict]:\n    \"\"\"Retrieve a list of possible position types\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int,dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/position_types\"\n    self.json = \"\"\n\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.position_types_id_get","title":"<code>position_types_id_get(id, ros=0)</code>","text":"<p>Retrieve the details about the position type with the specified type ID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>position type ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int,dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def position_types_id_get(self, id: str, ros: bool = 0) -&gt; [int,dict]:\n    \"\"\"Retrieve the details about the position type with the specified type ID\n\n    :param guid: position type ID\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int,dict]\n    \"\"\"\n\n    \"\"\" Position Types:\n    {'id': 0, 'name': 'Robot position', 'url': '/v2.0.0/position_types/0'},\n    {'id': 1, 'name': 'Cart position', 'url': '/v2.0.0/position_types/1'},\n    {'id': 2, 'name': 'Cart pickup position', 'url': '/v2.0.0/position_types/2'},\n    {'id': 3, 'name': 'Cart left entry', 'url': '/v2.0.0/position_types/3'},\n    {'id': 4, 'name': 'Cart right entry', 'url': '/v2.0.0/position_types/4'},\n    {'id': 5, 'name': 'Shelf position', 'url': '/v2.0.0/position_types/5'},\n    {'id': 6, 'name': 'Shelf short entry position', 'url': '/v2.0.0/position_types/6'},\n    {'id': 7, 'name': 'MiRCharge 100/200', 'url': '/v2.0.0/position_types/7'},\n    {'id': 8, 'name': 'MiRCharge 100/200 entry', 'url': '/v2.0.0/position_types/8'},\n    {'id': 9, 'name': 'V-marker', 'url': '/v2.0.0/position_types/9'},\n    {'id': 10, 'name': 'V-marker entry', 'url': '/v2.0.0/position_types/10'},\n    {'id': 11, 'name': 'VL-marker', 'url': '/v2.0.0/position_types/11'},\n    {'id': 12, 'name': 'VL-marker entry', 'url': '/v2.0.0/position_types/12'},\n    {'id': 13, 'name': 'L-marker', 'url': '/v2.0.0/position_types/13'},\n    {'id': 14, 'name': 'L-marker entry', 'url': '/v2.0.0/position_types/14'},\n    {'id': 15, 'name': 'Emergency position', 'url': '/v2.0.0/position_types/15'},\n    {'id': 16, 'name': 'Precision marker', 'url': '/v2.0.0/position_types/16'},\n    {'id': 17, 'name': 'Precision marker entry', 'url': '/v2.0.0/position_types/17'},\n    {'id': 18, 'name': 'Pallet rack', 'url': '/v2.0.0/position_types/18'},\n    {'id': 19, 'name': 'Pallet rack entry position', 'url': '/v2.0.0/position_types/19'},\n    {'id': 20, 'name': 'MiRCharge 500/1000', 'url': '/v2.0.0/position_types/20'},\n    {'id': 21, 'name': 'MiRCharge 500/1000 entry', 'url': '/v2.0.0/position_types/21'},\n    {'id': 22, 'name': 'Bar-marker', 'url': '/v2.0.0/position_types/22'},\n    {'id': 23, 'name': 'Bar-marker entry', 'url': '/v2.0.0/position_types/23'},\n    {'id': 25, 'name': 'elevator position', 'url': '/v2.0.0/position_types/25'},\n    {'id': 26, 'name': 'elevator entry position', 'url': '/v2.0.0/position_types/26'},\n    {'id': 42, 'name': 'Staging position', 'url': '/v2.0.0/position_types/42'},\n    {'id': 106, 'name': 'Shelf long entry position', 'url': '/v2.0.0/position_types/106'}]]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/position_types/\" + id\n    self.json = \"\"\n\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.positions_guid_get","title":"<code>positions_guid_get(guid, ros=0)</code>","text":"<p>Retrieve the details about the position with the specified GUID</p> <p>Parameters:</p> Name Type Description Default <code>guid</code> <code>str</code> <p>The global id unique across robots that identifies this position</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int,dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def positions_guid_get(self, guid: str, ros: bool = 0) -&gt; [int,dict]:\n    \"\"\"Retrieve the details about the position with the specified GUID\n\n    :param guid: The global id unique across robots that identifies this position\n    :type guid: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int,dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/positions/\" + guid\n    self.json = \"\"\n\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.positions_pos_id_docking_offsets_get","title":"<code>positions_pos_id_docking_offsets_get(pos_id, ros=0)</code>","text":"<p>Retrieve the details of the docking offset of the position with the specified position ID</p> <p>Parameters:</p> Name Type Description Default <code>pos_id</code> <code>str</code> <p>position ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int,dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def positions_pos_id_docking_offsets_get(self, pos_id: str, ros: bool = 0) -&gt; [int,dict]:\n    \"\"\"Retrieve the details of the docking offset of the position with the specified position ID\n\n    :param pos_id: position ID\n    :type pos_id: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int,dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/positions/\" + pos_id + \"/docking_offsets\"\n    self.json = \"\"\n\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.positions_post","title":"<code>positions_post(position, ros=0)</code>","text":"<p>Add a new position.</p> <p>Position json needs to have at least: {name, pos_x, pos_y, orientation, type_id, map_id}</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>json</code> <p>position json</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def positions_post(self, position, ros: bool = 0) -&gt; [int, dict]: \n    \"\"\"Add a new position.\n\n    Position json needs to have at least: {name, pos_x, pos_y, orientation, type_id, map_id}\n\n    :param position: position json\n    :type position: json\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int, dict]\n    \"\"\"\n\n    self.method = \"POST\"\n    self.endpoint = self.url + \"/positions\"\n    self.json = position\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.sessions_session_id_maps_get","title":"<code>sessions_session_id_maps_get(session_id, ros=0)</code>","text":"<p>Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>site ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def sessions_session_id_maps_get(self, session_id: str, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id\n\n    :param session_id: site ID\n    :type session_id: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/sessions/\" + session_id + \"/maps\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.setting_name_get","title":"<code>setting_name_get(group_name, setting_name, ros=0)</code>","text":"<p>Retrieve the details of the setting with the specified settings group name and setting name</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>settings group name</p> required <code>setting_name</code> <code>str</code> <p>setting name</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int,dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def setting_name_get(self, group_name: str, setting_name: str, ros: bool = 0) -&gt; [int,dict]:\n    \"\"\"Retrieve the details of the setting with the specified settings group name and setting name\n\n    :param group_name: settings group name\n    :type group_name: str\n    :param setting_name: setting name\n    :type setting_name: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int,dict]\n    \"\"\"\n\n    settings_list = self.settings_groups_name_get(group_name,ros)\n    setting = next(item for item in settings_list[1] if item[\"name\"] == setting_name)\n    return [settings_list[0], setting]\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.settings_groups_get","title":"<code>settings_groups_get(ros=0)</code>","text":"<p>Retrieve a list with the settings groups</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int, List[dict]]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def settings_groups_get(self, ros: bool = 0) -&gt; [int, List[dict]]:\n    \"\"\"Retrieve a list with the settings groups\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int, List[dict]]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/setting_groups\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.settings_groups_id_get","title":"<code>settings_groups_id_get(group_id, ros=0)</code>","text":"<p>Retrieve the list of settings from the settings group with the specified settings group ID</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>int</code> <p>settings group ID</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int, List[dict]]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def settings_groups_id_get(self, group_id: int, ros: bool = 0) -&gt; [int, List[dict]]:\n    \"\"\"Retrieve the list of settings from the settings group with the specified settings group ID\n\n    :param group_id: settings group ID\n    :type group_id: int\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int, List[dict]]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/setting_groups/\" + str(group_id) + \"/settings\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.settings_groups_name_get","title":"<code>settings_groups_name_get(group_name, ros=0)</code>","text":"<p>Retrieve the list of settings from the settings group with the specified settings group name</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>settings group name</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>[int, List[dict]]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def settings_groups_name_get(self, group_name: str, ros: bool = 0) -&gt; [int, List[dict]]:\n    \"\"\"Retrieve the list of settings from the settings group with the specified settings group name\n\n    :param group_name: settings group name\n    :type group_name: str\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: [int, List[dict]]\n    \"\"\"\n\n    groups = self.settings_groups_get(ros)\n    setting_group = next(item for item in groups[1] if item[\"name\"] == group_name)\n    setting_group = self.settings_groups_id_get(setting_group[\"id\"],ros)\n    return setting_group\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.status_get","title":"<code>status_get(ros=0)</code>","text":"<p>Retrieve the robot status</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def status_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the robot status\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/status\"\n    self.json = \"\"\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.status_mode_get","title":"<code>status_mode_get(ros=0)</code>","text":"<p>Retrieve the current mode of the robot</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def status_mode_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the current mode of the robot\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/status\"\n    self.json = \"\"\n    if ros == 1:\n        response =  self.handle_request_ros()\n        return [response[0], {\"mode_id\": response[1][\"mode_id\"],\"mode_text\": response[1][\"mode_text\"], \"mode_key_state\":response[1][\"mode_key_state\"]}]\n    else:\n        response =  self.handle_request()\n        return [response[0], {\"mode_id\": response[1][\"mode_id\"],\"mode_text\": response[1][\"mode_text\"], \"mode_key_state\":response[1][\"mode_key_state\"]}]\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.status_put","title":"<code>status_put(json, ros=0)</code>","text":"<p>Modify the robot status</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>dict</code> <p>request body</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def status_put(self, json: dict, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Modify the robot status\n\n    :param json: request body\n    :type json: dict\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"PUT\"\n    self.endpoint = self.url + \"/status\"\n    self.json = json\n    if ros == 1:\n        return self.handle_request_ros()\n    else:\n        return self.handle_request()\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.status_state_get","title":"<code>status_state_get(ros=0)</code>","text":"<p>Retrieve the current state of the robot</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def status_state_get(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Retrieve the current state of the robot\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    self.method = \"GET\"\n    self.endpoint = self.url + \"/status\"\n    self.json = \"\"\n    if ros == 1:\n        response =  self.handle_request_ros()\n        return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n    else:\n        response =  self.handle_request()\n        return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.status_state_id_put","title":"<code>status_state_id_put(state_id, ros=0)</code>","text":"<p>Modify the current state of the robot. </p> <p>Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}. Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>desired robot state</p> required <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def status_state_id_put(self, state_id: int, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Modify the current state of the robot. \n\n    Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}.\n    Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}.\n\n    :param state_id: desired robot state\n    :type state_id: int\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    if state_id !=3 and state_id != 4:\n        print(\"INVALID INPUT. Select state_id=3 for 'Ready' or state_id=4 for 'Pause'\")\n        return\n\n    self.method = \"PUT\"\n    self.endpoint = self.url + \"/status\"\n    self.json = {\"state_id\" : state_id}\n    if ros == 1:\n        response =  self.handle_request_ros()\n        return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n    else:\n        response =  self.handle_request()\n        return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n</code></pre>"},{"location":"MiR100/mir_rest_api/#api.MirRestApi.status_state_id_toggle_put","title":"<code>status_state_id_toggle_put(ros=0)</code>","text":"<p>Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'.</p> <p>Parameters:</p> Name Type Description Default <code>ros</code> <code>bool</code> <p>use ROS service, defaults to 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list[int, dict]</code> <p>a list containing REST response status code and body</p> Source code in <code>docs/MiR100/mir_rest_api/api.py</code> <pre><code>def status_state_id_toggle_put(self, ros: bool = 0) -&gt; [int, dict]:\n    \"\"\"Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'.\n\n    :param ros: use ROS service, defaults to 0\n    :type ros: bool, optional\n    :return: a list containing REST response status code and body\n    :rtype: list[int, dict]\n    \"\"\"\n\n    status = self.status_state_get(ros)[1]\n    if status[\"state_id\"] == 3:\n        state_id = 4\n        # rospy.loginfo(\"Setting the robot state to: 'Pause'\")\n        print(\"Robot is in state: 'Ready'. Setting the robot state to: 'Pause'\")\n    elif status[\"state_id\"] == 4:\n        state_id = 3\n        # rospy.loginfo(\"Setting the robot state to: 'Ready'\")\n        print(\"Robot is in state: 'Pause'. Setting the robot state to: 'Ready'/'Executing'\")\n    elif status [\"state_id\"] == 5:\n        state_id = 4\n        # rospy.loginfo(\"Setting the robot state to: 'Ready'\")\n        print(\"Robot is in state: 'Executing'. Setting the robot state to: 'Pause'\")\n    elif status [\"state_id\"] == 10:\n        # rospy.loginfo(\"Setting the robot state to: 'Ready'\")\n        print(\"Robot is in state: 'EmergencyStop'. Unable to toggle robot status\")\n        return\n    else:\n        # rospy.logerr(\"Unable to toggle robot status\")\n        print(\"Unable to toggle robot status\")\n        return\n\n    self.method = \"PUT\"\n    self.endpoint = self.url + \"/status\"\n    self.json = {\"state_id\" : state_id}\n    if ros == 1:\n        response =  self.handle_request_ros()\n        return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n    else:\n        response =  self.handle_request()\n        return [response[0], {\"state_id\": response[1][\"state_id\"],\"state_text\": response[1][\"state_text\"]}]\n</code></pre>"},{"location":"MiR100/mir_ros_control/","title":"ROS control","text":"<p>This page describes the ROS control for the <code>MiR100</code> robot only . To control the mobile base as part of the <code>MiRco</code> mobile manipulator see <code>MiRco</code> ROS control.  </p> <p>To establish a ROS connection with <code>MiR100</code> see Connect to <code>MiR100</code>.</p> <p>Warning</p> <p><code>MiR100</code> internal clock is prone to desynchronization which can mess with the robot control. Before controlling the robot, you have to connect to the MiR web interface and go to <code>System -&gt; Settings -&gt; Date &amp; Time</code> and synchronize the internal clock. Click <code>Load from device</code> and <code>Save changes</code>.</p> <p>Note</p> <p>For an advanced setup for clock synchronization see this solution.</p>"},{"location":"MiR100/mir_ros_control/#packages-overview","title":"Packages overview","text":"<ul> <li><code>mir_control:</code> main control package</li> <li><code>mir_rest_api:</code> MiR REST API</li> <li><code>mir_robot:</code> MiR ROS driver developed by the DFKI team</li> <li><code>mir_joy_teleop:</code> joystick control</li> </ul>"},{"location":"MiR100/mir_ros_control/#usage","title":"Usage","text":""},{"location":"MiR100/mir_ros_control/#start-mir_control","title":"Start mir_control","text":"<pre><code># MiR100 connection over hotspot\nroslaunch mir_control mir_control.launch\n\n# MiR100 connection over outside network\nroslaunch mir_control mir_control.launch mir_ip:=&lt;MiR100_IP&gt;\n</code></pre>"},{"location":"MiR100/mir_ros_control/#rviz","title":"RViz","text":"<p>TODO: check, make rviz config</p> <p>After you started <code>mir_control</code>, you can send the robot to a goal using the <code>2D Nav Goal</code> tool in RViz.  </p> <p>Make sure to set these RViz settings:</p> <pre><code>Panels -&gt; Tool Properties -&gt; 2D Nav Goal -&gt; Topic: /mir100/move_base_simple/goal\nPanels -&gt; Tool Properties -&gt; 2D Pose Estimate -&gt; Topic: /mir100/initialpose\nGlobal Options -&gt; Fixed Frame: map\n</code></pre> <p>Send the robot to a goal:</p> <ul> <li>use <code>2D Pose Estimate</code> to mark the approximate <code>MiR100</code> start location</li> <li>use <code>2D Nav Goal</code> to send the robot to a goal</li> </ul>"},{"location":"MiR100/mir_ros_control/#mir_control-package","title":"mir_control package","text":"<p>The main control package. This is a wrapper around the <code>mir_driver</code> package. For details about <code>mir_driver</code> see the GitHub page.</p> <p><code>mir_control</code> starts another <code>roscore</code> on the host computer, connecting to the <code>MiR100</code> internal <code>roscore</code> over <code>ROS Bridge</code>. See the MiRco ROS schematic for a visual aid of the connection.  </p> <p><code>mir_control</code> adds a control node, a python robot class, a goal teacher, ROS services and REST API integration. This effectively enables the use of all web interface functions.</p>"},{"location":"MiR100/mir_ros_control/#launch-files","title":"Launch files","text":""},{"location":"MiR100/mir_ros_control/#mir_controllaunch","title":"<code>mir_control.launch</code>","text":"<ul> <li>launches <code>mir_driver</code> </li> <li>launches <code>mir_control_node</code></li> </ul>"},{"location":"MiR100/mir_ros_control/#nodes","title":"Nodes","text":""},{"location":"MiR100/mir_ros_control/#mir_control_nodepy","title":"<code>mir_control_node.py</code>","text":"<p>The main control node for <code>MiR100</code>. Initializes a <code>MiR100</code> python object. See <code>mir100_class.py</code> script for details on the object.</p>"},{"location":"MiR100/mir_ros_control/#config-files","title":"Config files","text":""},{"location":"MiR100/mir_ros_control/#target_goalsyaml","title":"target_goals.yaml","text":"<p>When you run the control node, the positions in the current MiR map are saved in this file. If <code>taget_goals.yaml</code> already contains a position with the same name (this file is not reset on start), the old position is overwritten.</p> <pre><code># saved positions structure\nposition_name:\n  orientation:\n    w: 0.0112920402716304\n    x: 0.0\n    y: 0.0\n    z: -0.9999362428807668\n  position:\n    x: 21.218\n    y: 13.802\n    z: 0      # z coordinate is always saved as 0\n</code></pre>"},{"location":"MiR100/mir_ros_control/#markersyaml","title":"markers.yaml","text":"<p>When you run the control node, the markers in the current MiR map are saved in this file. This doesn't include marker entry positions. Currently only VL type markers are supported. If <code>markers.yaml</code> already contains a marker with the same name (this file is not reset on start), the old marker is overwritten.</p> <pre><code># saved markers structure\nmarker_name:\n  guid: 017f3480-fb3d-11ee-947c-94c691a73828\n  offsets_guid: 018037c1-fb3d-11ee-947c-94c691a73828\n  orientation_offset: 2.0\n  type_id: 11\n  x_offset: -0.6\n  y_offset: 0.0\n</code></pre>"},{"location":"MiR100/mir_ros_control/#services","title":"Services","text":"<p>Services are established with the <code>mir_control_node</code> or whenever you create a <code>MiR100</code> object defined in <code>mir100_class.py</code>.</p>"},{"location":"MiR100/mir_ros_control/#save_mobile_goal-todo-check-if-works-correctly","title":"save_mobile_goal (TODO: check if works correctly)","text":"<p>Saves the current <code>MiR100</code> pose under selected name. The pose is saved both in the web interface and in <code>/config/target_goals.yaml</code>.  </p> <p>If the current <code>MiR100</code> map does not include a position or marker with the same name, a position with the selected name is created and saved to the current MiR map. If a position or marker with the same name already exists, they are overwritten with the current <code>MiR100</code> pose.</p>"},{"location":"MiR100/mir_ros_control/#send_to_goal","title":"send_to_goal","text":"<p>Send robot to a goal saved in <code>/config/target_goals.yaml</code>.  </p>"},{"location":"MiR100/mir_ros_control/#get_markers","title":"get_markers","text":"<p>Get list of markers saved in <code>/config/markers.yaml</code>.</p>"},{"location":"MiR100/mir_ros_control/#dock_to_vl_marker","title":"dock_to_vl_marker","text":"<p>Start docking to the selected marker saved in <code>config/markers.yaml</code>.</p>"},{"location":"MiR100/mir_ros_control/#change_marker_offsets","title":"change_marker_offsets","text":"<p>Change the offsets of a marker saved in <code>/config/markers.yaml</code>. Currently only VL type markers are supported.  </p>"},{"location":"MiR100/mir_ros_control/#mir_joy_teleop-package","title":"mir_joy_teleop package","text":"<p>A package for joystick control.</p> <p>As with connecting to the robot, you can send the joystick commands directly to the <code>MiR100</code> internal <code>roscore</code> or use it with the <code>mir_control</code> package.</p> <p>Note</p> <p>When using <code>mir_control</code> we send <code>geometry_msgs/Twist</code> type messages instead of <code>geometry_msgs/TwistStamped</code> to the <code>/cmd_vel</code> topic. That is because the <code>mir_driver</code> package expects messages of type <code>geometry_msgs/Twist</code> on the <code>/cmd_vel</code> topic and converts them to <code>geometry_msgs/TwistStamped</code> messages before sending the commands to the robot.</p>"},{"location":"MiR100/mir_ros_control/#internal","title":"Internal","text":"<p>Follow the Establish ROS connection - internal roscore instructions. Then run:</p> <pre><code># launch a joy_node and a teleop node\nroslaunch mir_joy_teleop joy_teleop.launch\n\n# default input device is js1\n# you can specify input device - e.g. js2\n$ roslaunch mir_joy_teleop joy_teleop.launch device:=js2\n</code></pre>"},{"location":"MiR100/mir_ros_control/#mir_control-package_1","title":"mir_control package","text":"<p>Follow the Establish ROS connection - mir_control package instructions. Then run: <pre><code># launch a joy_node and a teleop node\nroslaunch mir_joy_teleop joy_teleop.launch roscore:=external\n\n# default input device is js1\n# specify input device - e.g. js2\n$ roslaunch mir_joy_teleop joy_teleop.launch device:=js2 roscore:=external\n</code></pre></p>"},{"location":"MiR100/mir_start/","title":"Starting MiR100","text":""},{"location":"MiR100/mir_start/#pre-check","title":"Pre-check","text":"<p>Before turning on the power, make sure that the <code>MiR100</code> battery has enough charge. Check by plugging in the charger. LED lights on the charger will indicate battery status. See MiR charging instructions.</p>"},{"location":"MiR100/mir_start/#power","title":"Power","text":"<p>To turn on <code>MiR100</code> press the blue button on its front right corner.</p> <p> </p>"},{"location":"MiR100/mir_start/#post-check","title":"Post-check","text":"<p>When you turn on the robot it could be in emergency stop. This is indicated by the red light indication on the robot. Release the red emergency stop button and press the blue reset button.</p> <p> </p>"},{"location":"MiR100/mir_start/#mir100-charging-instructions","title":"MiR100 charging instructions","text":""},{"location":"MiR100/mir_start/#start-charging","title":"Start charging","text":"<ul> <li>Plug in the provided charger into an outlet. Wait for the LEDs on the charger to indicate its ready state</li> <li>Remove the cover of the charging port. The charging port is located in the back left corner of the robot (opposite of the on/off switch)</li> <li>Plug the charger in the charging port</li> <li>Turn on the rocker switch above the charging port</li> <li><code>MiR100</code> battery percentage is indicated on the charger and in the web interface.  </li> </ul>"},{"location":"MiR100/mir_start/#stop-charging","title":"Stop charging","text":"<ul> <li>First turn off the rocker switch above the charging port</li> <li>Remove the charging cable and put on the charging port cover</li> </ul> <p>TODO:photos</p>"},{"location":"MiR100/mir_web_interface/","title":"MiR web interface","text":"<p>This is an overview of the MiR web interface. Here you will find the most common MiR web interface functions. This is not a complete how-to on the use of the web interface capabilities. For detailed information about the interface see the MiR\u00a0robot Reference Guide pdf. </p> <p>To establish a connection to the MiR web interface see Connect to <code>MiR100</code>.</p> <p>Warning</p> <p><code>MiR100</code> internal clock is prone to desynchronization which can mess with the robot control. First thing you have to do after you connect to the MiR web interface is go to <code>System -&gt; Settings -&gt; Date &amp; Time</code> and synchronize the internal clock. Click <code>Load from device</code> and <code>Save changes</code>.</p>"},{"location":"MiR100/mir_web_interface/#interface-overview","title":"Interface overview","text":""},{"location":"MiR100/mir_web_interface/#top-bar","title":"Top bar","text":"<p>The top bar shows information on the current state of the robot. You can start/pause the robot, check robot status, select you language, select your user, check the robot battery percentage or manually control the robot with the on screen joystick. Robot speed for manual control is fixed when using the joystick from the top bar. This is not the recommended use of joystick. Use the FE_joysticks dashboard </p> <p></p>"},{"location":"MiR100/mir_web_interface/#navigation","title":"Navigation","text":"<p>To get to a specific subsection of the interface select an item in the primary menu and then in the relevant submenu.</p> <p></p>"},{"location":"MiR100/mir_web_interface/#interface-menus","title":"Interface menus","text":""},{"location":"MiR100/mir_web_interface/#dashboards-menu","title":"Dashboards menu","text":"<p>Dashboards are the main way you interact with the robot over the web interface. A dashboard is made up of a number of widgets, each representing a feature in the system, such as a particular mission, the map the robot is running in, or the current mission queue. You can create your own dashboard that displays only relevant information for your use case. The dashboard below includes a Mission queue, mission action log, two mission buttons, a joystick and the map.</p> <p></p>"},{"location":"MiR100/mir_web_interface/#creating-a-dashboard","title":"Creating a dashboard","text":"<p>Select <code>Dashboards</code> to open the list of dashboards, and select the <code>Create dashboard</code> button to open the dashboard designer. Alternatively, you can select an existing dashboard from the list to edit. Design the dashboard by selecting widgets from the menus in the top bar. Resize the widgets by pulling the arrow in the lower right corner and rearrange their order by selecting and dragging them. Some widgets require further settings. For example, you must select a particular mission for mission buttons. To do this, select the pen icon in the lower left corner and select the wanted action.</p> <p></p>"},{"location":"MiR100/mir_web_interface/#example-dashboards","title":"Example dashboards","text":"<p>In the dashboards list you can find the FE_standard and FE_joysticks dashboards. FE_standard is a template for a standard use case and is a good starting place for designing your own. FE_joysticks is a dashboard that contains only joystick control widgets where each joystick has a different speed setting. This is practical for manual control of the robot where you want to use different speeds - slower for narrower areas, and faster for open space. The best way to use the joystick is to access the web interface on your phone and guide the robot with your finger.</p> <p>TODO: joystick dashboard screenshot</p>"},{"location":"MiR100/mir_web_interface/#setup-menu","title":"Setup menu","text":""},{"location":"MiR100/mir_web_interface/#missions-submenu","title":"Missions submenu","text":"<p>A mission is a predefined series of actions that the robot can be set to perform. It can be a simple transportation task between defined positions or a more complex job. The robot will perform the missions in the order they are added, and an operator may rearrange the queued missions if needed.  </p> <p>Missions are started by adding a mission to the mission queue and clicking on the continue button in the top bar or in the dashboard, if you add the pause/continue widget. The robot will perform the missions in the order they are added, and you can rearrange the queued missions if needed. You can enqueue a mission:</p> <ul> <li>from a dashboard: you can configure a mission button</li> <li>from the missions menu: in the mission list click on the green button next to the selected mission.</li> </ul>"},{"location":"MiR100/mir_web_interface/#creating-a-mission","title":"Creating a mission","text":"<p>A mission is made up of actions, such as: move actions, logic actions, docking actions and sounds, which can be put together to form a mission. Missions themselves can also be nested into other missions. Most actions have adjustable parameters, for example, which position to go to and can also use variables, enabling the user to choose the value of a parameter each time the mission is used. Access these parameters with the gear button.</p> <p>To create a new mission select <code>Setup -&gt; Missions -&gt; Create mission</code> to open the mission designer. In the top bar you can choose the actions or missions that you want to add to the mission. You can drag and drop to rearrange the order. Actions are executed in a top-to-bottom order.</p> <p>You can view all the possible actions in the MiR\u00a0robot Reference Guide.</p>"},{"location":"MiR100/mir_web_interface/#maps-submenu","title":"Maps submenu","text":"<p>In the Maps section, you create or edit the maps the robot uses to navigate by. All maps must belong to a site, which is the overall container for one or more maps used in the same facility. Maps must be contained in the same site for the robot to be able to move from one map to another. You can choose the active map by clicking the check mark next to the map on the map list. You can also create or edit the maps the robot uses. </p> <p></p>"},{"location":"MiR100/mir_web_interface/#creating-a-map","title":"Creating a map","text":"<p>To create a new map select <code>Setup -&gt; Maps -&gt; Create map</code>. You are then directed to the map editor where you can start the mapping process and find tools to edit the map and add various features such as positions, markers and zones.</p> <p>The built-in mapping functionality makes it possible to draw a map by manually driving the robot around the facility using the joystick while the robot uses the laser scanners to map the area. When mapping the robot speed is fixed. Slowly move the joystick to get used to the speed. You can create maps using two mapping algorithms.</p> <p>The map recording and editing tools are all found on the icon tool bar, and the drop-down list contains all the features you can add to your map. Different tools are displayed on the icon toolbar depending on which feature you have selected from the drop-down list.</p> <p></p> <p>Press the 3-dots icon to open the Upload, download and record map dialog box. This toolbar has options for recording a new map or uploading/downloading existing ones.</p> <ul> <li>Upload and overwrite: erases the existing map and replaces it with the map you upload</li> <li>Upload and append: adds the uploaded map to the existing one</li> <li>Download map: saves the map to your PC as a PNG file</li> <li>Record and overwrite: erases the existing map and replaces it with the map you record</li> <li>Record and append: adds the recorded map to the existing one</li> </ul> <p></p> <p>Select <code>Record and overwrite</code> or <code>Record and append</code> to start the mapping engine. A blinking icon indicates that the recording has started, and you can now activate the joystick and start moving the robot around the area. To stop the mapping engine, press the record icon in the upper-left corner of the recording window.</p> <p>After the mapping engine stops, you can rotate the map and align it using the grid. When you finish the editing, select the check mark in the upper left-hand corner to save the map.</p>"},{"location":"MiR100/mir_web_interface/#edit-the-map","title":"Edit the map","text":"<p>When the map recording is done, modify the map by removing unwanted \"noise\", adding virtual walls, preferred or unpreferred drive zones, positions, markers and other features.</p> <p>The left side tool bar has the basic tools for saving, undoing, and navigating in the map you are working on. Furthermore, different tools appear on the tool bar depending on which map layer you select from the Object types drop-down list.</p> <p></p> <p>The Select object-list contains all features that you can add to the map, such as positions, markers, zones, walls, and floors. View all object descriptions in the MiR\u00a0robot Reference Guide.</p> <p></p> <p>The right side tool bar has tools for controlling the map view and synchronizing the robot\u2019s position with the map view.</p> <p></p> <p>Bellow is an image of a finished map. It contains multiple robot positions, a marker and two forbidden zones (red).</p> <p></p>"},{"location":"MiR100/mir_web_interface/#other-setup-submenus","title":"Other setup submenus","text":"<ul> <li>Sounds submenu: you can upload new sounds to the robot or edit the volume and length of the uploaded sounds. Sounds can be used in missions as alerts.</li> <li>Transitions submenu: transitions are used to handle changeovers from one map to another within the same site. </li> <li>I/O modules submenu: I/O modules (Bluetooth and WISE) are used for receiving and giving input and output to be able to communicate with external devices.</li> <li>Users submenu: set up, edit, and delete system users.</li> <li>User groups submenu: create user groups and assign permissions to each group.</li> <li>Paths submenu: Paths are saved routes between two positions. The first time the robot runs the route between two positions, the calculated path is saved and used every time the robot runs the same route, thereby saving time for route calculation. A path is automatically recalculated only in the event that one of its positions is modified. You can delete a path, and the robot will then calculate a new path the next time it runs between those two positions.</li> <li>Path guides submenu: A path guide makes it possible to define paths that the robot should follow between two positions by defining waypoint positions between the start and goal. </li> <li>Footprints submenu: A footprint defines the size of the robot and its top module or load.</li> </ul>"},{"location":"MiR100/mir_web_interface/#monitoring-menu","title":"Monitoring menu","text":"<ul> <li>Analytics submenu: gives a graphic overview of the robot's driven distance over a specified period of time.</li> <li>System log submenu: contains events that are logged by the operating system components. The system log contains information about system state at a given time (shown by color-codes), the affected module, a short explanation, and a time stamp.</li> <li>Error logs submenu: a list of all detected system errors. Each entry is shown with a description, an indication of which module is affected, and the time when the error occurred.</li> <li>Hardware health submenu: allows you to check the condition of the robot's hardware components, such as motor controllers, lasers scanners, and cameras.</li> <li>Safety system submenu: provides a live view of the input from the laser scanners and the state of the emergency stop button.</li> <li>Mission log submenu: contains the list of all missions that the robot has executed and the mission that is running now. </li> </ul>"},{"location":"MiR100/mir_web_interface/#system-menu","title":"System menu","text":""},{"location":"MiR100/mir_web_interface/#settings-submenu","title":"Settings submenu","text":"<p>Settings contains the robot's parameter settings where the settings are divided into sub groups. Here are some of the most important settings:</p>"},{"location":"MiR100/mir_web_interface/#mapping-settings","title":"Mapping settings","text":"<ul> <li><code>Mapping -&gt; Mapping algorithm</code>: the algorithm the robot uses for creating maps. Choose between Hector and Carthographer (default). The Cartographer method records multiple smaller maps and then compiles those into one map after the recording session. It is recommended to map in a circular pattern and closing loops. The Hector method records and compiles data in one map during the mapping. It is recommended to map in a branch pattern, while going back over your own tracks several times.</li> </ul>"},{"location":"MiR100/mir_web_interface/#planner-settings","title":"Planner settings","text":"<ul> <li><code>Planner -&gt; Desired speed</code>: the desired default speed in m/s. This value can also be changed through a mission action.</li> <li><code>Planner -&gt; Maximum allowed speed</code>: the robot's maximum speed in m/s which cannot be exceeded no matter what is stated in missions, zones, or other settings.</li> <li><code>Planner -&gt; Cart reverse speed</code>: the speed in m/s of the robot when it is reversing with a cart.</li> <li><code>Planner -&gt; Maximum planning time</code>: the maximum time in seconds allocated for planning a path.</li> <li><code>Planner -&gt; Path timeout</code>: the number of seconds where the robot cannot follow the path before it generates a new global plan.</li> <li><code>Planner -&gt; Path deviation</code>: the maximum distance in meters that the robot's local plan is allowed to deviate from the global plan.</li> </ul>"},{"location":"MiR100/mir_web_interface/#ur-interface-settings","title":"UR interface settings","text":"<ul> <li><code>UR interface -&gt; Universal Robot IP address</code>: the IP address of the UR robot. Used with the <code>MiRco</code> industrial interface control.</li> </ul>"},{"location":"MiR100/mir_web_interface/#features-settings","title":"Features settings","text":"<ul> <li><code>Features -&gt; Universal Robots Interface</code>: enable the running UR programs from inside MiR missions. Used with the <code>MiRco</code> industrial interface control.</li> </ul>"},{"location":"MiR100/mir_web_interface/#wifi-settings","title":"WiFi settings","text":"<ul> <li><code>WiFi -&gt; Add connection</code>: used to connect <code>MiR100</code> to an outside network. Select the network you wish to connect and fill in the required information. <code>MiR100_IP</code> is displayed under the network connection details. When the user and <code>MiR100</code> are connected to the same outside network, you can use this IP to access the web interface.</li> </ul>"},{"location":"MiR100/mir_web_interface/#date-time-settings","title":"Date &amp; Time settings","text":"<ul> <li><code>Date&amp;Time -&gt; Load from device -&gt; Save changes</code>: synchronize the internal clock. Since the internal clock is prone to desynchronization this needs to be done on every boot.</li> </ul>"},{"location":"MiR100/mir_web_interface/#other-system-submenus","title":"Other system submenus","text":"<ul> <li>Processes submenu: displays the software modules that control the system processes on the robot.</li> <li>PLC registers submenu: registers can be accessed through a serial interface using the robot\u2019s USB port (via RS232 adapter) or through a REST interface using the robot\u2019s Ethernet connection. </li> <li>Software versions submenu: you can update the robot to run the newest software and see a list of all previous versions installed on the robot</li> <li>Backups submenu: copies of the configuration and system state data of your robot</li> <li>Robot setup submenu: contains the robot configuration and calibration properties.</li> <li>Triggers submenu: yhe robot can be set up to use Modbus TCP/IP communication. In the Triggers section you can set up links between robot missions and Modbus coil IDs</li> </ul>"},{"location":"MiR100/mir_web_interface/#help-menu","title":"Help menu","text":"<ul> <li>Robot information submenu: contains robot information.</li> <li>API documentation submenu: All functionality found in the robot interface can also be accessed through the robot's REST API. The REST API is what the robot interface uses to communicate with the robot. Here you can try the REST API. Enter your username and password and then select Launch API documentation. Each endpoint you can use is documented, and you can select Try it out to send an API request using the entered authorization. We also made a python REST API for the MiRco robot.</li> <li>Remote access submenu: MiR Technical Support team remote access.</li> <li>Service book submenu: notes about the robot.</li> <li>Manual submenu: copy of the reference guide.</li> </ul>"},{"location":"MiR100/mir_web_interface/#control-the-robot","title":"Control the robot","text":""},{"location":"MiR100/mir_web_interface/#send-to-goal","title":"Send to goal","text":"<p>TODO:check these instruction</p> <p>The main way to control <code>MiR100</code> is through missions, however you can also send the robot to individual goals.  </p> <ul> <li>Send to target: use the map to send <code>MiR100</code> to a goal not predefined (as a position or marker) on the active map. Click on the position on the map and use your mouse to set the orientation</li> <li>Send to position: select the chosen position on the active map and select <code>Go TO</code></li> <li>Send to marker: select the chosen marker on the active map and select <code>Go TO</code></li> </ul> <p>Each of these command will add an action to the mission queue. You can append them or overwrite the queue.</p>"},{"location":"MiR100/mir_web_interface/#manual-control","title":"Manual control","text":"<p>The easiest way to move <code>MiR100</code> to a desired goal is to manually control the robot.</p> <p>The web interface has an onscreen joystick in the top bar of the interface but as mentioned, this is not the recommended method since the robot speed when using the top bar joystick is fixed. This can cause problems in narrow areas. Instead use the FE_joysticks dashboard - it includes multiple onscreen joystick widgets with different speeds. </p> <p>The best way to use the joystick is to access the web interface on your phone and guide the robot with your finger.</p>"},{"location":"MiRco/mirco_connection/","title":"Connect to MiRco","text":""},{"location":"MiRco/mirco_connection/#connect-to-mirco-pc","title":"Connect to <code>MiRco PC</code>","text":"<p><code>MiRco PC</code> is connected to the lab network however it does not have a static <code>MiRco_IP</code> (for now).</p>"},{"location":"MiRco/mirco_connection/#if-you-know-mirco_ip","title":"If you know <code>MiRco_IP</code>","text":"<p>If you know <code>MiRco_IP</code> you can connect to <code>MiRco PC</code> in the following ways:</p> <ul> <li>Ssh: <code>ssh student@MiRco_IP</code> and sign in.</li> <li>Remote desktop: To use remote desktop <code>MiRco PC</code> needs a connected monitor so make sure the virtual DisplayPort adapter is plugged in. Use AnyDesk, <code>MiRco PC</code> shows up under network discovered devices. If not, use <code>MiRco_IP</code>.</li> <li>Connect a display, computer and mouse directly to the computer </li> </ul>"},{"location":"MiRco/mirco_connection/#if-you-dont-know-mirco_ip","title":"If you don't know <code>MiRco_IP</code>","text":"<p>Connect to the computer over remote desktop (AnyDesk). You have to be connected to the same network (lab network by default). If that doesn't work plug in a display. When connected, open the terminal and look up <code>MiRco_IP</code> with <code>ifconfig</code>.</p>"},{"location":"MiRco/mirco_connection/#development-tips","title":"Development tips","text":"<ul> <li>Connection over remote desktop will always be lacking. Use it only when visual tools like <code>RViz</code> are needed. When possible connect to the robot over <code>ssh</code>. </li> <li>When writing or testing code on <code>MiRco</code>, use the <code>Remote-SSH</code> extension for <code>VSCodium</code> or <code>VSCode</code>. It enables you to remotely access files on the MiRco computer within your development environment. There is no lag issue like with remote desktop and the robot is still free to move (as opposed to connecting a monitor).</li> <li>If you are using a Docker installation on your robot, use the <code>Dev Containers</code> extension for <code>VSCode</code>. It enables you to access container files within your development environment. If you use it in combination with the <code>Remote-SSH</code> extension, you can access files within a container running on your robot computer. This extension is only available for <code>VSCode</code> and not for <code>VSCodium</code>. </li> </ul>"},{"location":"MiRco/mirco_industrial_control/","title":"MiRco industrial interface control","text":"<p>Before controlling <code>MiRco</code> it is recommended to read the MiRco interface chapter of the documentation.</p> <p>Make sure to follow the industrial interface parts of the Starting <code>MiRco</code> instructions.</p> <ul> <li> <p>Design the UR program normally.</p> </li> <li> <p>Design the MiR mission. In the place where you want to perform robot manipulation insert the <code>UR -&gt; Run UR program</code> action. Set the <code>program name</code> parameter to the UR program absolute path without the .urp extension. <code>MiR100</code> will wait for <code>UR5e</code> to finish program execution and then continue with its mission.</p> </li> </ul>"},{"location":"MiRco/mirco_industrial_control/#usage","title":"Usage","text":"<ul> <li>set <code>UR5e</code> to <code>Remote control</code> mode</li> <li>add MiR mission to the mission queue</li> <li>start mission execution in the web interface</li> </ul> <p>Note</p> <p>By installing a plugin for the Polyscope software package - a URCap, the functionality of the UR teach pendant can be extended. The plugin allows starting and stopping <code>MiR100</code> missions, reading and writing <code>MiR100</code> registers and accessing <code>MiR100</code> states such as battery status, robot status and mission status. This documentation does not cover the use of this URCap.</p>"},{"location":"MiRco/mirco_interface/","title":"MiRco interface","text":"<p>There are two ways of controlling <code>MiRco</code>:</p> <ul> <li>MiRco industrial interface: uses pre-existing option within the robots interfaces for communication between a MiR and a UR robot.</li> <li>MiRco ROS interface: uses a <code>MiRco PC</code> running ROS to control <code>MiRco</code>.</li> </ul>"},{"location":"MiRco/mirco_interface/#mirco-industrial-interface","title":"MiRco industrial interface","text":"<p>MiR and UR already include the ability to connect robots for basic synchronous operation using a MiR action. MiR action only takes care of the synchronization of the task handover. The individual robot tasks - MiR missions and UR programs - have to be predefined in their interfaces, then the task execution is handled by their respective control systems. The <code>UR5e</code> manipulator has to be in remote control mode. For instructions see <code>MiRco</code> industrial interface control. A schematic representation of a simple example is shown below.</p> <p>The user launches the mobile manipulation application through the MiR web interface. The task of synchronizing the robots is performed by the <code>MiR100</code> platform, where the communication between robots is done over an Ethernet connection. Within the <code>MiR100</code> mission, at the point where the manipulation is to be performed, an action is added to start the <code>UR5e</code> program. <code>MiR100</code> loads the program, runs it and waits for the end of the execution. The UR program contains manipulation and gripper instructions. <code>MiR100</code> then proceeds with the execution of the mission.</p> <p>Note</p> <p>By installing a plugin for the Polyscope software package - a URCap, the functionality of the UR teach pendant can be extended. The plugin allows starting and stopping <code>MiR100</code> missions, reading and writing <code>MiR100</code> registers and accessing <code>MiR100</code> states such as battery status, robot status and mission status. This documentation does not cover the use of this URCap.</p>"},{"location":"MiRco/mirco_interface/#mirco-ros-interface","title":"MiRco ROS interface","text":"<p>When the robot is controlled over the ROS interface, the <code>MiRco PC</code> takes over the role of the central control system. The schematic of the system is shown below. <code>MiRco PC</code> is connected to the internal <code>MiR100</code> computer over WiFi (MiR_R*** hotspot or the same outside network), and to the <code>UR5e</code> controller over Ethernet, through which the connections to the manipulator and gripper are established. The computer runs a ROS instance with a unified robot model and ROS drivers for the mobile platform, manipulator and gripper. </p> <p>With this setup, communication with <code>MiR100</code> takes place on two levels. The first level is the MiR REST API. The API provides access to most of the functions of the MiR web interface, such as accessing predefined missions, triggering the docking action, saving robot poses and retrieving the robot state. The second level is direct communication with the ROS instance running on <code>MiR100</code> internal computer. Both ROS instances, on <code>MiRco PC</code> and on <code>MiR100</code>, act as master, so communication between them is done using the <code>ROSBridge</code> package. <code>MiR100</code> is running a customized version of the ROS navigation stack, through which the platform can be controlled. By using the REST API and direct communication with ROS, we achieve the use of all capabilities of the mobile platform. </p> <p>Note</p> <p>In this setup, the ROS navigation stack used is the <code>MiR100</code> navigation stack. Target goals are sent to the <code>MiR100</code> <code>move_base</code> node, and the robot navigation stack handles planning and execution. However, you could implement your own navigation stack on the <code>MiRco PC</code> side and publish commands to the <code>cmv_vel</code> topic of the <code>MiR100</code> robot.</p> <p>Communication with <code>UR5e</code> and the <code>Robotiq 2F-85</code> gripper is done over an Ethernet connection. <code>MiRco PC</code> is connected to the <code>UR5e</code> controller, over which communication with the gripper is established. <code>UR5e</code> manipulation is planned and executed using the <code>MoveIt</code> package.</p>"},{"location":"MiRco/mirco_overview/","title":"MiRco overview","text":"<p><code>MiRco</code> is a mobile manipulator consisting of commercially available components combined in a custom housing. It integrates <code>MiR100</code> autonomous mobile robot with the <code>UR5e</code> manipulator arm. </p> <p>Control is possible with both the industrial and ROS interfaces - see MiRco interfaces.</p> <p>MiRco components:</p> <ul> <li>MiR100: autonomous mobile robot</li> <li>UR5e: collaborative industrial manipulator</li> <li>Robotiq 2f85: electronic gripper</li> <li>MiRco PC: control computer</li> <li>Power: 24V LiFePO4 battery + 24V DC / 230V AC inverter. Used to power the <code>UR5e</code> manipulator. Can also use direct power from an outlet.</li> </ul>"},{"location":"MiRco/mirco_ros_control/","title":"MiRco ROS interface control","text":"<p>Before controlling <code>MiRco</code> it is recommended to read the MiRco interface chapter of the documentation.</p> <p>Make sure to follow the ROS interface parts of the Starting <code>MiRco</code> instructions.</p>"},{"location":"MiRco/mirco_ros_control/#packages-overview","title":"Packages overview","text":"<ul> <li><code>mirco_robot:</code> main control package</li> <li><code>mirco_description:</code> URDF description and launch files</li> <li><code>mirco_moveit_config:</code> MoveIt! configuration and launch files</li> </ul> <p>For an overview of the individual ROS packages for <code>MiR100</code> and <code>UR5e</code> see the <code>MiR100</code> and <code>UR5e</code> ROS control documentation.</p>"},{"location":"MiRco/mirco_ros_control/#usage","title":"Usage","text":""},{"location":"MiRco/mirco_ros_control/#start-mirco-control","title":"Start MiRco control","text":"<ul> <li> <p>Prepare the robot arm. On the teach pendant load the external control UR program program. Power on and start the robot manipulator.</p> </li> <li> <p>Run <code>mirco_bringup.launch</code>. Wait until the \"subscribing to\" &amp; \"publishing to\" messages stop appearing. This means the connection is established <pre><code># MiR100 connection over hotspot\nroslaunch mirco_robot mirco_bringup.launch\n\n# MiR100 connection over outside network\nroslaunch mirco_robot mirco_bringup.launch mir_ip:=&lt;MiR100_IP&gt;\n</code></pre> If you know <code>MiR100_IP</code> will not be changing (if you set up static IP) you can edit <code>mirco_bringup.launch</code> as: <pre><code># line 7\n&lt;arg name=\"mir_ip\" default=\"&lt;MiR100_IP&gt;\" doc=\"MiR IP address\"/&gt;\n\n# then, while connected to an outside network, you can run \nroslaunch mirco_robot mirco_bringup.launch\n</code></pre></p> </li> <li> <p>Start the external control UR program on the teach pendant. In the terminal where you launched <code>mirco_bringup</code> you should see: <pre><code>Robot connected to reverse interface. Ready to receive control commands\n</code></pre></p> </li> <li> <p>In another terminal run <code>mirco_control.launch</code>.  <pre><code>roslaunch mirco_robot mirco_control.launch\n</code></pre></p> </li> </ul>"},{"location":"MiRco/mirco_ros_control/#rviz","title":"RViz","text":"<p>After you started MiRco control, you can send the robot to a goal using the <code>2D Nav Goal</code> tool in RViz.  </p> <p>Send the robot to a goal:</p> <ul> <li>open rviz <pre><code>roslaunch mirco_robot view_mirco.launch\n</code></pre></li> <li>Make sure these RViz settings are set: <pre><code>Panels -&gt; Tool Properties -&gt; 2D Nav Goal -&gt; Topic: /mirco/mir100/move_base_simple/goal\nPanels -&gt; Tool Properties -&gt; 2D Pose Estimate -&gt; Topic: /mirco/mir100/initialpose\nGlobal Options -&gt; Fixed Frame: map\n</code></pre></li> <li>use <code>2D Pose Estimate</code> to mark the approximate MiR100 start location</li> <li>use <code>2D Nav Goal</code> to send the robot to a goal</li> </ul> <p>TODO: check rviz config</p>"},{"location":"MiRco/mirco_ros_control/#mirco_robot-package","title":"mirco_robot package","text":"<p>Overview of the main control package.</p>"},{"location":"MiRco/mirco_ros_control/#launch-files","title":"Launch files","text":"<p>mirco_bringup.launch</p> <ul> <li>sets <code>MiRco</code>, <code>MiR100</code>, <code>UR5e</code> and <code>2F-85</code> namespaces and TF prefixes</li> <li>sets robot IPs for the robot drivers</li> <li>loads ROS parameters and <code>MiRco</code> URDF model</li> <li>establishes connection with <code>MiR100</code>, <code>UR5e</code> and <code>2F-85</code></li> </ul> <p>mirco_control.launch</p> <ul> <li>launches <code>mir_control_node</code></li> <li>launches !MoveIt for the manipulator</li> </ul> <p>ur_control.launch: Part of the <code>UR5e</code> ROS driver</p> <p>view_mirco.launch: Launches RViz with saved config</p> <p>delivery.launch</p> <p>Demo delivery application inside Robolab. Needs (TODO:map name) to be the active <code>MiR100</code> map. Expects the use of the VL docking marker. </p> <ul> <li>delivers a gear to a station</li> <li>places the gear on the station</li> <li>goes away</li> <li>returns to the station and picks up the gear</li> <li>goes to an end position </li> </ul> <p>conveyor.launch: Demo pick and place application for the manipulator. Same as <code>delivery.launch</code> without repositioning of the mobile base.</p>"},{"location":"MiRco/mirco_ros_control/#config-files","title":"Config files","text":""},{"location":"MiRco/mirco_ros_control/#arm_gripper_joint_sourcesyaml","title":"arm_gripper_joint_sources.yaml","text":"<p><code>MiRco</code> uses 2 <code>joint_state_publisher</code> nodes. </p> <p>One collects the sepparate joint states information of <code>UR5e</code> and <code>2F-85</code>. It then combines them and publishes them to the <code>/mirco_namespace/ur5e/joint_states</code> topic.</p> <p>The other collects the combined joint states information of <code>UR5e</code> and <code>2F-85</code> (from the first publisher) and the joint states of <code>MiR100</code>. It then publishes them to the <code>/mirco_namespace/joint_states</code> topic.</p> <p>This confg file contains sources for where the first publisher looks for this joint information.</p>"},{"location":"MiRco/mirco_ros_control/#robot_joint_sourcesyaml","title":"robot_joint_sources.yaml","text":"<p><code>MiRco</code> uses 2 <code>joint_state_publisher</code> nodes. </p> <p>One collects the sepparate joint states information of <code>UR5e</code> and <code>2F-85</code>. It then combines them and publishes them to the <code>/mirco_namespace/ur5e/joint_states</code> topic.</p> <p>The other collects the combined joint states information of <code>UR5e</code> and <code>2F-85</code> (from the first publisher) and the joint states of <code>MiR100</code>. It then publishes them to the <code>/mirco_namespace/joint_states</code> topic.</p> <p>This confg file contains sources for where the second publisher looks for this joint information.</p>"},{"location":"MiRco/mirco_ros_control/#ur5e_saved_posesyaml","title":"ur5e_saved_poses.yaml","text":"<p>File used to save manipulator poses as joint states. Used by <code>save_arm_pose</code>, <code>set_arm_pose</code>, <code>get_arm_pose</code> and <code>get_arm_pose_names</code> services to save or retrieve manipulator joint states.</p> <pre><code># saved pose example\nentry1:\n  ur5e_elbow_joint: -1.9254509210586548\n  ur5e_shoulder_lift_joint: -1.3431395900300522\n  ur5e_shoulder_pan_joint: -0.07610828081239873\n  ur5e_wrist_1_joint: -1.4239323896220704\n  ur5e_wrist_2_joint: 1.5782090425491333\n  ur5e_wrist_3_joint: -0.07931977907289678\n</code></pre>"},{"location":"MiRco/mirco_ros_control/#services","title":"Services","text":"<ul> <li><code>MiR100</code> services</li> <li><code>UR5e</code> services</li> </ul>"},{"location":"MiRco/mirco_start/","title":"Starting MiRco","text":""},{"location":"MiRco/mirco_start/#pre-checks","title":"Pre-checks","text":"<p>Before turning on the power, make sure that:</p> <ul> <li><code>MiRco</code> battery has enough charge. If not, you can plug in the cable for direct power. You can check battery status with the button on the charge controller on <code>MiRco</code>'s right side. </li> <li><code>MiR100</code> battery has enough charge. Check by plugging in the charger. LED lights on the charger will indicate battery status. See MiR charging instructions.</li> <li>Connection with <code>UR5e</code> controller:<ul> <li>For <code>MiRco</code> industrial interface control: connect the red Ethernet cable to the <code>UR5e</code> controller</li> <li>For <code>MiRco</code> ROS interface control: connect the white Ethernet cable to the <code>UR5e</code> controller</li> </ul> </li> <li><code>UR5e</code> controller is using the correct configuration. This is important because URCaps conflicts can impede gripper control. The only URCaps on the controller should be the externalcontrol-x.x.x.urcap and rs485-x.x.x.urcap.</li> </ul> <p>TODO: add pictures</p>"},{"location":"MiRco/mirco_start/#power","title":"Power","text":"<ul> <li>turn on the <code>MiRco</code> battery: power switch on the left side of the housing. Wait for the double audio signal</li> <li>turn on <code>MiRco PC</code>: PC power switch inside the housing</li> <li>turn on <code>MiR100</code>: blue button on the front right corner</li> <li>turn on <code>UR5e</code>: power button on the teach pendant</li> </ul>"},{"location":"MiRco/mirco_start/#mir100-settings","title":"MiR100 settings","text":"<p>Warning</p> <p>MiR100 internal clock is prone to desynchronization which can mess with the robot control. Before controlling the robot, you have to connect to the MiR web interface and go to <code>System -&gt; Settings -&gt; Date &amp; Time</code> and synchronize the internal clock. Click <code>Load from device</code> and <code>Save changes</code>.</p> <p>Get the <code>MiR100_IP</code>. In the MiR web interface go to <code>System -&gt; Settings -&gt; WiFi</code>. <code>MiR100_IP</code> is listed under the connection details</p>"},{"location":"MiRco/mirco_start/#mirco-industrial-interface","title":"MiRco industrial interface","text":"<p>For industrial interface control we need to enter <code>UR5e_IP</code> address in the MiR web interface.</p> <ul> <li>Go to <code>System -&gt; Settings -&gt; Features</code> and make sure the Universal Robots Interface is enabled.</li> <li>Go to <code>System -&gt; Settings -&gt; UR Interface</code> and enter <code>UR5e_IP</code> address. This IP has to match the IP in the <code>UR5e</code> network settings bellow. <pre><code># Universal Robot IP address:\n192.168.12.244 # example IP\n</code></pre></li> </ul>"},{"location":"MiRco/mirco_start/#ur5e-settings","title":"UR5e settings","text":""},{"location":"MiRco/mirco_start/#mirco-industrial-interface_1","title":"MiRco industrial interface","text":"<p>The IP address of the internal computer in <code>MiR100</code> is <code>192.168.12.20</code>. To establish a connection between the robots, <code>UR5e</code> static IP address should be in the range of <code>192.168.12.xxx</code> where xxx is a number from 100\u2013255.</p> <p>Go to <code>Settings -&gt; System -&gt; Network</code> and make sure the network settings are correct.</p> <pre><code>IP address: 192.168.12.244 # example IP\nSubnet mask: 255.255.255.0\n</code></pre>"},{"location":"MiRco/mirco_start/#mirco-ros-interface","title":"MiRco ROS interface","text":"<p>Go to <code>Settings -&gt; System -&gt; Network</code> and make sure the network settings are correct. This is the <code>UR5e_IP</code> address that the <code>MiRco PC</code> uses to control the arm.</p> <pre><code>IP address: 192.168.77.245\nSubnet mask: 255.255.255.0\n</code></pre> <p>Go to <code>Installation -&gt; URCaps -&gt; External control</code> and make sure the network settings are correct. This is the <code>MiRco_IP</code> address that <code>UR5e</code> uses to know where the control is coming from.</p> <pre><code>Host IP: 192.168.77.240\nCustom port: 50002\nHost name: 192.168.77.240\n</code></pre>"},{"location":"MiRco/mirco_start/#external-control-ur-program","title":"External control UR program","text":"<p>Design a UR program to use the externalcontrol-x.x.x.urcap URCap to allow external communication with the manipulator. </p> <p>Create a new program and insert the External Control program node into the program tree. Save the program. You will see the <code>Host IP</code> and <code>Custom port</code> that you configured in the previous step.</p> <p>There is a program already prepared. To use it load the <code>home/magisterij/janjericevic/mir100_ur5e_ros</code> program. </p> <p>TODO: rename ur program, screenshot with correct ip</p>"},{"location":"MiRco/mirco_start/#mirco-charging-instructions","title":"MiRco charging instructions","text":""},{"location":"MiRco/mirco_start/#direct-power","title":"Direct power","text":"<p><code>MiRco</code> can run on direct power from an outlet. This is useful when developing parts of applications where <code>MiRco</code> is stationary. This does not power <code>MiR100</code>.</p> <p>Plug the power cable to the direct power plug on the left side of <code>MiRco</code>'s housing, below the power switch.</p>"},{"location":"MiRco/mirco_start/#start-charging","title":"Start charging","text":"<ul> <li><code>MiR100</code> charging: see <code>MiR100</code> charging instructions</li> <li><code>MiRco</code> battery: plug in the charger to an outlet. When the charger LED light lights up, plug the charger to the <code>MiRco</code> battery charging plug on the left side of <code>MiRco</code>'s housing, below the power switch</li> </ul>"},{"location":"MiRco/mirco_start/#stop-charging","title":"Stop charging","text":"<ul> <li><code>MiR100</code>: see <code>MiR100</code> charging instructions</li> <li><code>MiRco</code> battery: remove the charger from the <code>MiRco</code> battery charging plug</li> </ul> <p>TODO:photos</p>"},{"location":"UR5e_2F85/ur_2f85_overview/","title":"UR5e &amp; Robotiq 2F-85 overview","text":"<p><code>UR5e</code> is a collaborative industrial robotic manipulator from Universal Robots (UR). The manipulator weighs 20 kg, has 6 degrees of freedom (DOF), a load capacity of 5 kg and a working area with a radius of 850 mm. The manipulator has force and obstacle detection capabilities and includes various configurable safety features. </p> <p>Application design is done via the Polyscope software package on a touch-screen teach pendant.  </p> <p><code>2f85</code> is Robotiq's adaptive robotic gripper for use with collaborative robots. The gripper has adjustable gripping stroke from 0 to 85 mm with a resolution of 0.4 mm. It is capable of parallel gripping with a force of 20-235 N and a speed of 20-150 mm/s. The gripper is connected to the manipulator on the flange, with communication via the Modbus RTU protocol.</p> <p>This documentation describes only the ROS control of the manipulator with the gripper. For control and application design using the teach pendant see their original documentation.</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/","title":"ROS control","text":"<p>This page describes the ROS control for the <code>UR5e</code> manipulator &amp; <code>Robotiq 2F-85</code> gripper only . To control the manipulator and gripper as part of the <code>MiRco</code> mobile manipulator see MiRco ROS control.  </p> <p>Before controlling the robot follow the Starting UR5e &amp; Robotiq 2F-85 instructions.</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#packages-overview","title":"Packages overview","text":"<ul> <li><code>ur5e_2f85:</code> main control package</li> <li><code>ur5e_2f85_description:</code> URDF description, kinematics calibration and controllers configuration files for <code>UR5e</code> with the attached <code>2F-85</code></li> <li><code>ur5e_2f85_moveit_config:</code> MoveIt! configuration and launch files</li> <li><code>robotiq_2f85:</code> Robotiq ROS driver, specifically for <code>2F-85</code> gripper. Fork of the original driver </li> </ul>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#usage","title":"Usage","text":"<p>TODO: test</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#ur5e_2f85-package","title":"ur5e_2f85 package","text":"<p>The main control package</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#launch-files","title":"Launch files","text":"<p>TODO: test</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#nodes","title":"Nodes","text":"<p>TODO: test</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#config-files","title":"Config files","text":""},{"location":"UR5e_2F85/ur_2f85_ros_control/#ur5e_saved_posesyaml","title":"ur5e_saved_poses.yaml","text":"<p>File used to save manipulator poses as joint states. Used by <code>save_arm_pose</code>, <code>set_arm_pose</code>, <code>get_arm_pose</code> and <code>get_arm_pose_names</code> services to save or retrieve manipulator joint states.</p> <pre><code># saved pose example\nentry1:\n  ur5e_elbow_joint: -1.9254509210586548\n  ur5e_shoulder_lift_joint: -1.3431395900300522\n  ur5e_shoulder_pan_joint: -0.07610828081239873\n  ur5e_wrist_1_joint: -1.4239323896220704\n  ur5e_wrist_2_joint: 1.5782090425491333\n  ur5e_wrist_3_joint: -0.07931977907289678\n</code></pre>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#services","title":"Services","text":""},{"location":"UR5e_2F85/ur_2f85_ros_control/#save_arm_pose","title":"save_arm_pose","text":"<p>Saves the current manipulator pose as joint states. The pose is saved in <code>/config/ur5e_save_poses.yaml</code> under a selected name.</p> <p>If <code>/config/ur5e_save_poses.yaml</code> does not include a pose with the same name, a pose with the selected name is created and saved to the file. If a pose with the same name already exists, it's overwritten with the current joint states.</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#set_arm_pose","title":"set_arm_pose","text":"<p>Sets manipulator to a selected pose saved as joint states in <code>/config/ur5e_save_poses.yaml</code>. Uses MoveJ.</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#get_arm_pose","title":"get_arm_pose","text":"<p>Gets a manipulator pose as joint states. Returns a pose saved in <code>/config/ur5e_save_poses.yaml</code> specified with the pose name.</p>"},{"location":"UR5e_2F85/ur_2f85_ros_control/#get_arm_pose_names","title":"get_arm_pose_names","text":"<p>Gets a list of poses saved in <code>/config/ur5e_save_poses.yaml</code>.</p>"},{"location":"UR5e_2F85/ur_2f85_start/","title":"Starting UR5e &amp; Robotiq 2F-85","text":""},{"location":"UR5e_2F85/ur_2f85_start/#pre-check","title":"Pre-check","text":"<p>Before turning on the power, make sure that:</p> <ul> <li>The <code>control PC</code> is connected to the UR5e controller with an Ethernet cable. <code>control PC</code> is the computer you use to control the manipulator with ROS.</li> <li><code>UR5e</code> controller is using the correct configuration. This is important because URCaps conflicts can impede gripper control. The only URCaps on the controller should be the externalcontrol-x.x.x.urcap and rs485-x.x.x.urcap URCaps.</li> </ul>"},{"location":"UR5e_2F85/ur_2f85_start/#power","title":"Power","text":"<p>To turn on <code>UR5e</code> press the power button on the teach pendant. Gripper gets its power from the robot manipulator.</p>"},{"location":"UR5e_2F85/ur_2f85_start/#ur5e-settings","title":"UR5e settings","text":"<p>Go to <code>Settings -&gt; System -&gt; Network</code> and configure the network settings. This is the <code>UR5e_IP</code> address that the <code>control PC</code> uses to control the arm.</p> <pre><code># example configuration\nIP address: 192.168.77.245\nSubnet mask: 255.255.255.0\n</code></pre> <p>Go to <code>Installation -&gt; URCaps -&gt; External control</code> and configure the network settings for external control. This is the <code>control PC</code> IP address that <code>UR5e</code> uses to know where the control is coming from.</p> <pre><code># example configuration\nHost IP: 192.168.77.240\nCustom port: 50002\nHost name: 192.168.77.240\n</code></pre>"}]}